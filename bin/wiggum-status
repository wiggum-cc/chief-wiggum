#!/usr/bin/env bash
# Show status of workers
set -euo pipefail

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
source "$WIGGUM_HOME/lib/core/exit-codes.sh"
source "$WIGGUM_HOME/lib/core/defaults.sh"
source "$WIGGUM_HOME/lib/core/verbose-flags.sh"
source "$WIGGUM_HOME/lib/worker/worker-lifecycle.sh"
source "$WIGGUM_HOME/lib/utils/calculate-cost.sh"

show_help() {
    cat << EOF
wiggum status - Show status of workers

Usage: wiggum status [options]

Options:
  -v, --verbose       Verbose output (same as default)
  -vv                 Debug output (detailed diagnostics)
  -vvv                Trace output (very detailed tracing)
  -q, --quiet         Quiet mode (warnings and errors only)
  -h, --help          Show this help message

Description:
  Displays the current status of all workers including:
  - Which workers are running
  - Worker PIDs
  - How long the task has been running
  - Context window usage ([MODEL] Context: N%)
  - Recent activity from logs

Examples:
  wiggum status        # Show current worker status

EOF
}

# Format duration in human-readable format
# Args: duration_seconds
# Returns: formatted string like "2h 15m" or "45m 30s" or "10s"
format_duration() {
    local seconds="$1"
    local hours=$((seconds / 3600))
    local minutes=$(((seconds % 3600) / 60))
    local secs=$((seconds % 60))

    if ((hours > 0)); then
        echo "${hours}h ${minutes}m"
    elif ((minutes > 0)); then
        echo "${minutes}m ${secs}s"
    else
        echo "${secs}s"
    fi
}

# Extract start timestamp from worker directory name
# Worker format: worker-TASK-XXX-<timestamp>
# Args: worker_name
# Returns: timestamp (Unix epoch seconds) or empty if not found
get_worker_start_timestamp() {
    local worker_name="$1"
    # Extract the timestamp suffix (last component after final dash)
    if [[ "$worker_name" =~ -([0-9]+)$ ]]; then
        echo "${BASH_REMATCH[1]}"
    fi
}

# Parse verbose flags first
parse_verbose_flags "$@"
set -- "${WIGGUM_REMAINING_ARGS[@]}"

# Parse options
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit $EXIT_OK
            ;;
        *)
            echo "Unknown option: $1"
            echo ""
            show_help
            exit $EXIT_USAGE
            ;;
    esac
done

# Check for active workers by scanning worker directories
if [ ! -d "$RALPH_DIR/workers" ]; then
    echo "No wiggum workers found in this project"
    exit $EXIT_OK
fi

# Collect active workers using shared library
worker_count=0
running_count=0
declare -a worker_pids=()
declare -a worker_names=()

# Count total workers with PID files
for worker_dir in "$RALPH_DIR/workers"/worker-*; do
    [ -d "$worker_dir" ] || continue
    [ -f "$worker_dir/agent.pid" ] || continue
    ((++worker_count))
done

# Get running workers using shared library
scan_output=$(scan_active_workers "$RALPH_DIR") || {
    scan_rc=$?
    if [ "$scan_rc" -eq 2 ]; then
        log_warn "Worker scan encountered lock contention, results may be incomplete"
    fi
}
while read -r pid _task_id worker_id; do
    [ -n "$pid" ] || continue
    ((++running_count))
    worker_pids+=("$pid")
    worker_names+=("$worker_id")
done <<< "$scan_output"

# Check if any workers are running
if [ $running_count -eq 0 ]; then
    echo "No wiggum process running in this project"
    exit $EXIT_OK
fi

echo "=== Chief Wiggum Status ==="
echo "Project: $PROJECT_DIR"
echo ""

# Check orchestrator status
orchestrator_lock="$RALPH_DIR/.orchestrator.pid"
if [ -f "$orchestrator_lock" ]; then
    orchestrator_pid=$(cat "$orchestrator_lock" 2>/dev/null)
    if [[ "$orchestrator_pid" =~ ^[0-9]+$ ]] && kill -0 "$orchestrator_pid" 2>/dev/null; then
        if ps -p "$orchestrator_pid" -o args= 2>/dev/null | grep -q "wiggum-run"; then
            echo "Orchestrator: RUNNING (PID: $orchestrator_pid)"
        else
            echo "Orchestrator: NOT RUNNING (stale lock)"
        fi
    else
        echo "Orchestrator: NOT RUNNING (stale lock)"
    fi
else
    echo "Orchestrator: NOT RUNNING"
fi
echo ""

# Display running workers with duration and context usage
for i in "${!worker_pids[@]}"; do
    worker_name="${worker_names[$i]}"
    worker_pid="${worker_pids[$i]}"
    worker_dir="$RALPH_DIR/workers/$worker_name"

    # Calculate running duration from worker start timestamp
    duration_info=""
    start_ts=$(get_worker_start_timestamp "$worker_name")
    if [ -n "$start_ts" ]; then
        now_ts=$(date +%s)
        duration=$((now_ts - start_ts))
        if ((duration >= 0)); then
            duration_info=" [$(format_duration "$duration")]"
        fi
    fi

    # Get context usage if available
    context_info=""
    if [ -d "$worker_dir/logs" ]; then
        context_result=$(calculate_latest_context_usage "$worker_dir/logs" 2>/dev/null) || true
        if [ -n "$context_result" ]; then
            read -r model_name _context_tokens _context_size context_percent <<< "$context_result"
            context_info=" - [$model_name] Context: ${context_percent}%"
        fi
    fi

    echo "âœ“ Worker $worker_name (PID: $worker_pid) - RUNNING$duration_info$context_info"
done

echo ""
echo "Total: $worker_count workers, $running_count running"

# Show recent activity from logs
if [ -f "$RALPH_DIR/logs/workers.log" ]; then
    echo ""
    echo "Recent activity (last 5 lines):"
    tail -5 "$RALPH_DIR/logs/workers.log" | sed 's/^/  /'
fi
