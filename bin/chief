#!/usr/bin/env bash
# Chief Wiggum - Worker launcher and manager

CHIEF_HOME="${CHIEF_HOME:-$HOME/.claude/chief-wiggum}"
PROJECT_DIR="$(pwd)"
RALPH_DIR="$PROJECT_DIR/.ralph"

source "$CHIEF_HOME/lib/task-parser.sh"
source "$CHIEF_HOME/lib/logger.sh"
source "$CHIEF_HOME/lib/file-lock.sh"

# Default configuration
MAX_WORKERS=4

show_help() {
    cat << EOF
Chief Wiggum - Autonomous Worker Orchestration

Usage: chief <command> [options]

Commands:
  init             Initialize .ralph/ directory in current project
  run              Orchestrate workers for incomplete tasks
  stop             Stop all running workers
  cleanup          Clean up worktrees and worker directories
  status           Show status of workers and tasks
  monitor          Monitor worker logs in real-time
  integrate        Manage worker Pull Requests

Run Options:
  --max-workers N      Maximum concurrent workers (default: 4)

Examples:
  chief init                   # Initialize project
  chief run                    # Start orchestration (max 4 workers)
  chief run --max-workers 8    # Start with max 8 workers
  chief stop                   # Stop all workers
  chief cleanup                # Clean up worktrees
  chief status                 # Show worker status
  chief monitor                # Monitor worker output
  chief integrate              # Manage PRs

Behavior:
  - Chief assigns pending tasks [ ] to workers
  - Tasks are marked in-progress [=] when assigned
  - Workers mark tasks complete [x] when done
  - Chief waits until all tasks are complete
  - New workers spawn as old ones finish (up to max)

For more help on specific commands:
  chief-integrate --help
  chief-monitor --help

EOF
}

main() {
    # Require a command
    if [ $# -eq 0 ]; then
        echo "Error: No command specified"
        echo ""
        show_help
        exit 1
    fi

    # Parse command
    local command="$1"
    shift

    case "$command" in
        init)
            exec "$CHIEF_HOME/bin/chief-init"
            ;;
        run)
            # Parse run options
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --max-workers)
                        if [[ -z "$2" ]] || [[ "$2" =~ ^- ]]; then
                            echo "Error: --max-workers requires a number argument"
                            exit 1
                        fi
                        MAX_WORKERS="$2"
                        shift 2
                        ;;
                    -h|--help)
                        show_help
                        exit 0
                        ;;
                    -*)
                        echo "Unknown option: $1"
                        echo ""
                        show_help
                        exit 1
                        ;;
                    *)
                        echo "Unknown argument: $1"
                        echo ""
                        show_help
                        exit 1
                        ;;
                esac
            done
            # Continue to orchestration below
            ;;
        stop)
            exec "$CHIEF_HOME/bin/chief-stop"
            ;;
        cleanup)
            exec "$CHIEF_HOME/bin/chief-cleanup"
            ;;
        status)
            exec "$CHIEF_HOME/bin/chief-status"
            ;;
        monitor)
            exec "$CHIEF_HOME/bin/chief-monitor" "$@"
            ;;
        integrate)
            exec "$CHIEF_HOME/bin/chief-integrate" "$@"
            ;;
        -h|--help|help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown command: $command"
            echo ""
            show_help
            exit 1
            ;;
    esac

    # Initialize project if needed
    if [ ! -d "$RALPH_DIR" ]; then
        log_error ".ralph/ directory not found. Run 'chief init' first."
        exit 1
    fi

    if [ ! -f "$RALPH_DIR/kanban.md" ]; then
        log_error ".ralph/kanban.md not found. Create a kanban file first."
        exit 1
    fi

    log "Starting Chief Wiggum in $PROJECT_DIR (max $MAX_WORKERS concurrent workers)"
    echo ""
    echo "Press Ctrl+C to stop and view 'chief status' for details"
    echo "=========================================="
    echo ""

    # Track active workers
    declare -A active_workers  # PID -> task_id mapping
    local all_pids=()
    local iteration=0

    # Main orchestration loop
    while true; do
        ((iteration++))
        # Get incomplete tasks ([ ] status)
        local pending_tasks=$(get_todo_tasks "$RALPH_DIR/kanban.md")

        # Clean up finished workers
        for pid in "${!active_workers[@]}"; do
            if ! kill -0 "$pid" 2>/dev/null; then
                log "Worker for ${active_workers[$pid]} finished (PID: $pid)"
                unset active_workers[$pid]
            fi
        done

        # Check if we're done (no pending tasks and no active workers)
        if [ -z "$pending_tasks" ] && [ ${#active_workers[@]} -eq 0 ]; then
            log "All tasks completed!"
            break
        fi

        # Spawn workers for pending tasks (up to MAX_WORKERS limit)
        for task_id in $pending_tasks; do
            # Check if we're at max capacity
            if [ ${#active_workers[@]} -ge $MAX_WORKERS ]; then
                break
            fi

            # Mark task as in-progress in kanban
            log "Assigning $task_id to new worker"
            if ! update_kanban_status "$RALPH_DIR/kanban.md" "$task_id" "="; then
                log_error "Failed to mark $task_id as in-progress"
                continue
            fi

            # Spawn worker
            spawn_worker "$task_id" &
            local worker_pid=$!
            active_workers[$worker_pid]="$task_id"
            all_pids+=($worker_pid)
            log "Spawned worker for $task_id (PID: $worker_pid)"
        done

        # Save all PIDs for chief-stop
        if [ ${#all_pids[@]} -gt 0 ]; then
            printf '%s\n' "${all_pids[@]}" > "$RALPH_DIR/.chief.pid"
        fi

        # Show status and recent activity
        if [ ${#active_workers[@]} -gt 0 ]; then
            echo ""
            echo "=== Status Update (iteration $iteration) ==="
            echo "Active workers: ${#active_workers[@]}/$MAX_WORKERS"

            # Show which tasks are being worked on
            echo "In Progress:"
            for pid in "${!active_workers[@]}"; do
                echo "  - ${active_workers[$pid]} (PID: $pid)"
            done

            # Show recent log activity (last 10 lines)
            if [ -f "$RALPH_DIR/logs/workers.log" ]; then
                echo ""
                echo "Recent activity:"
                tail -n 10 "$RALPH_DIR/logs/workers.log" 2>/dev/null | sed 's/^/  /'
            fi
            echo "=========================================="
        fi

        # Wait a bit before checking again
        sleep 5
    done

    # Cleanup
    rm -f "$RALPH_DIR/.chief.pid"

    echo ""
    echo "=========================================="
    log "Chief Wiggum finished - all tasks complete!"
    echo ""

    # Show final summary
    local completed_count=$(grep -c '^\- \[x\]' "$RALPH_DIR/kanban.md" 2>/dev/null || echo "0")
    echo "Summary:"
    echo "  - Total tasks completed: $completed_count"
    echo "  - Changelog: .ralph/changelog.md"
    echo ""
    echo "Next steps:"
    echo "  - Review completed work: chief integrate list"
    echo "  - Merge PRs: chief integrate merge-all"
    echo "  - Clean up: chief cleanup"
    echo ""
}

spawn_worker() {
    local task_id="$1"
    local worker_id="worker-${task_id}-$$"
    local worker_dir="$RALPH_DIR/workers/$worker_id"

    # Create worker directory
    mkdir -p "$worker_dir"
    mkdir -p "$RALPH_DIR/logs"

    # Extract task from kanban and create worker PRD
    extract_task "$task_id" "$RALPH_DIR/kanban.md" > "$worker_dir/prd.md"

    # Launch worker
    export WORKER_ID="$worker_id"
    export TASK_ID="$task_id"
    export CHIEF_HOME
    bash "$CHIEF_HOME/lib/worker.sh" "$worker_dir" "$PROJECT_DIR" >> "$RALPH_DIR/logs/workers.log" 2>&1
}

main "$@"
