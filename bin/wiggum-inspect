#!/usr/bin/env bash
# Inspect Chief Wiggum workers, pipelines, and agents for debugging
set -euo pipefail

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
source "$WIGGUM_HOME/lib/core/exit-codes.sh"
source "$WIGGUM_HOME/lib/core/defaults.sh"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

show_help() {
    cat << 'EOF'
wiggum inspect - Debug workers, pipelines, and agents

Usage: wiggum inspect <command> [args]

Commands:
  worker <pattern>      Show worker state and files
  pipeline [file]       Show pipeline configuration
  agents                List available agents with configs
  activity [pattern]    Show activity log (global or per-worker)
  step <pattern>        Show current pipeline step for worker

Options:
  -h, --help            Show this help message
  --json                Output in JSON format (where applicable)
  -n, --lines <N>       Number of log lines to show (default: 20)

Examples:
  wiggum inspect worker TASK-001
  wiggum inspect pipeline
  wiggum inspect pipeline config/pipeline.json
  wiggum inspect agents
  wiggum inspect activity
  wiggum inspect activity TASK-001
  wiggum inspect step TASK-001

EOF
}

# Find worker directory matching pattern
find_worker() {
    local pattern="$1"
    local matches=()

    if [ ! -d "$RALPH_DIR/workers" ]; then
        return 1
    fi

    for dir in "$RALPH_DIR/workers"/worker-*; do
        if [ -d "$dir" ]; then
            local dirname
            dirname=$(basename "$dir")
            if [[ "$dirname" =~ $pattern ]]; then
                matches+=("$dir")
            fi
        fi
    done

    if [ ${#matches[@]} -eq 0 ]; then
        echo "No workers found matching: $pattern" >&2
        return 1
    elif [ ${#matches[@]} -gt 1 ]; then
        echo "Multiple workers match '$pattern':" >&2
        for m in "${matches[@]}"; do
            echo "  $(basename "$m")" >&2
        done
        echo "Please be more specific." >&2
        return 1
    fi

    echo "${matches[0]}"
}

# Inspect a worker's state
cmd_worker() {
    local pattern="$1"
    local worker_dir
    worker_dir=$(find_worker "$pattern") || exit 1
    local worker_name
    worker_name=$(basename "$worker_dir")

    echo -e "${BOLD}Worker: ${CYAN}$worker_name${NC}"
    echo -e "${DIM}Path: $worker_dir${NC}"
    echo ""

    # Status
    local status="unknown"
    local pid_file="$worker_dir/agent.pid"
    if [ -f "$pid_file" ]; then
        local pid
        pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            status="${GREEN}running${NC} (PID: $pid)"
        else
            status="${YELLOW}stopped${NC} (stale PID: $pid)"
        fi
    else
        status="${DIM}no PID file${NC}"
    fi
    echo -e "${BOLD}Status:${NC} $status"

    # Gate result
    local gate_file="$worker_dir/gate_result"
    if [ -f "$gate_file" ]; then
        local result
        result=$(cat "$gate_file")
        local color="$NC"
        case "$result" in
            PASS) color="$GREEN" ;;
            FAIL) color="$RED" ;;
            FIX)  color="$YELLOW" ;;
            STOP) color="$RED" ;;
        esac
        echo -e "${BOLD}Gate Result:${NC} ${color}${result}${NC}"
    fi

    # Current step
    local step_file="$worker_dir/step-config.json"
    if [ -f "$step_file" ]; then
        local step_id agent
        step_id=$(jq -r '.step_id // "unknown"' "$step_file" 2>/dev/null)
        agent=$(jq -r '.agent // "unknown"' "$step_file" 2>/dev/null)
        echo -e "${BOLD}Current Step:${NC} $step_id (${CYAN}$agent${NC})"
    fi
    echo ""

    # Files
    echo -e "${BOLD}Files:${NC}"
    local files=("prd.md" "gate_result" "step-config.json" "activity.jsonl" "agent.pid")
    for f in "${files[@]}"; do
        if [ -f "$worker_dir/$f" ]; then
            local size
            size=$(wc -c < "$worker_dir/$f" | tr -d ' ')
            echo -e "  ${GREEN}✓${NC} $f ${DIM}(${size}B)${NC}"
        else
            echo -e "  ${DIM}✗ $f${NC}"
        fi
    done

    # Output directories
    if [ -d "$worker_dir/output" ]; then
        echo ""
        echo -e "${BOLD}Output Directories:${NC}"
        for d in "$worker_dir/output"/*/; do
            if [ -d "$d" ]; then
                local dname
                dname=$(basename "$d")
                local file_count
                file_count=$(find "$d" -type f | wc -l | tr -d ' ')
                echo -e "  ${BLUE}$dname/${NC} ${DIM}($file_count files)${NC}"
            fi
        done
    fi

    # Recent activity
    local activity_file="$worker_dir/activity.jsonl"
    if [ -f "$activity_file" ] && [ -s "$activity_file" ]; then
        echo ""
        echo -e "${BOLD}Recent Activity:${NC}"
        tail -5 "$activity_file" | while read -r line; do
            local ts event
            ts=$(echo "$line" | jq -r '.ts // ""' 2>/dev/null | sed 's/T/ /' | cut -c12-19)
            event=$(echo "$line" | jq -r '.event // ""' 2>/dev/null)
            echo -e "  ${DIM}$ts${NC} $event"
        done
    fi
}

# Inspect pipeline configuration
cmd_pipeline() {
    local file="${1:-}"

    # Resolve pipeline file
    if [ -n "$file" ]; then
        if [ ! -f "$file" ]; then
            echo "Pipeline file not found: $file" >&2
            exit 1
        fi
    elif [ -f "$RALPH_DIR/pipeline.json" ]; then
        file="$RALPH_DIR/pipeline.json"
    elif [ -f "config/pipeline.json" ]; then
        file="config/pipeline.json"
    elif [ -f "$WIGGUM_HOME/config/pipeline.json" ]; then
        file="$WIGGUM_HOME/config/pipeline.json"
    else
        echo "No pipeline configuration found" >&2
        exit 1
    fi

    echo -e "${BOLD}Pipeline:${NC} $file"
    echo ""

    # Parse and display
    local name step_count
    name=$(jq -r '.name // "unnamed"' "$file")
    step_count=$(jq '.steps | length' "$file")

    echo -e "${BOLD}Name:${NC} $name"
    echo -e "${BOLD}Steps:${NC} $step_count"
    echo ""

    # Step table
    echo -e "${BOLD}Step${NC}              ${BOLD}Agent${NC}                           ${BOLD}Max${NC}   ${BOLD}Flags${NC}"
    echo -e "${DIM}────────────────  ──────────────────────────────  ────  ─────${NC}"

    jq -r '.steps[] | [.id, .agent, (.max // 0),
        (if .readonly then "R" else "" end) +
        (if .commit_after then "C" else "" end) +
        (if .enabled_by then "E" else "" end) +
        (if .on_result then "H" else "" end)
    ] | @tsv' "$file" | while IFS=$'\t' read -r id agent max flags; do
        printf "%-16s  %-30s  %-4s  %s\n" "$id" "$agent" "$max" "$flags"
    done

    echo ""
    echo -e "${DIM}Flags: R=readonly, C=commit_after, E=enabled_by, H=has on_result handlers${NC}"

    # Show on_result handlers
    local handlers
    handlers=$(jq -r '[.steps[] | select(.on_result) | {id, on_result}] | length' "$file")
    if [ "$handlers" -gt 0 ]; then
        echo ""
        echo -e "${BOLD}Result Handlers:${NC}"
        jq -r '.steps[] | select(.on_result) | "  \(.id): " + (.on_result | keys | join(", "))' "$file"
    fi
}

# List available agents
cmd_agents() {
    local config_file="$WIGGUM_HOME/config/agents.json"

    if [ ! -f "$config_file" ]; then
        echo "Agent config not found: $config_file" >&2
        exit 1
    fi

    echo -e "${BOLD}Available Agents${NC}"
    echo ""

    # List agents with their configs
    echo -e "${BOLD}Agent${NC}                            ${BOLD}Iterations${NC}  ${BOLD}Turns${NC}  ${BOLD}Timeout${NC}"
    echo -e "${DIM}───────────────────────────────  ──────────  ─────  ───────${NC}"

    jq -r '.agents | to_entries[] | [.key, (.value.max_iterations // "-"), (.value.max_turns // "-"), (.value.timeout_seconds // "-")] | @tsv' "$config_file" | \
    while IFS=$'\t' read -r name iters turns timeout; do
        printf "%-31s  %-10s  %-5s  %s\n" "$name" "$iters" "$turns" "${timeout}s"
    done

    echo ""
    echo -e "${BOLD}Defaults:${NC}"
    jq -r '.defaults | to_entries[] | "  \(.key): \(.value)"' "$config_file"

    # List agent script files
    echo ""
    echo -e "${BOLD}Agent Scripts:${NC}"
    find "$WIGGUM_HOME/lib/agents" -name "*.sh" -type f | sort | while read -r script; do
        local rel_path="${script#$WIGGUM_HOME/lib/agents/}"
        local agent_name="${rel_path%.sh}"
        agent_name="${agent_name//\//.}"
        echo -e "  ${CYAN}$agent_name${NC} ${DIM}→ $rel_path${NC}"
    done
}

# Show activity log
cmd_activity() {
    local pattern="${1:-}"
    local lines="${LINES_COUNT:-20}"
    local log_file=""

    if [ -n "$pattern" ]; then
        # Worker-specific activity
        local worker_dir
        worker_dir=$(find_worker "$pattern") || exit 1
        log_file="$worker_dir/activity.jsonl"
        echo -e "${BOLD}Activity Log:${NC} $(basename "$worker_dir")"
    else
        # Global activity
        log_file="$RALPH_DIR/logs/activity.jsonl"
        echo -e "${BOLD}Activity Log:${NC} Global"
    fi

    if [ ! -f "$log_file" ]; then
        echo "No activity log found: $log_file" >&2
        exit 1
    fi

    echo -e "${DIM}$log_file${NC}"
    echo ""

    if [ "$JSON_OUTPUT" = true ]; then
        tail -"$lines" "$log_file"
    else
        echo -e "${BOLD}Time${NC}      ${BOLD}Event${NC}                    ${BOLD}Details${NC}"
        echo -e "${DIM}────────  ───────────────────────  ─────────────────────${NC}"

        tail -"$lines" "$log_file" | while read -r line; do
            local ts event worker_id step_id
            ts=$(echo "$line" | jq -r '.ts // ""' 2>/dev/null | sed 's/T/ /' | cut -c12-19)
            event=$(echo "$line" | jq -r '.event // ""' 2>/dev/null)
            worker_id=$(echo "$line" | jq -r '.worker_id // ""' 2>/dev/null)
            step_id=$(echo "$line" | jq -r '.step_id // ""' 2>/dev/null)

            local details=""
            [ -n "$worker_id" ] && details="$worker_id"
            [ -n "$step_id" ] && details="${details:+$details }step=$step_id"

            printf "%-8s  %-23s  %s\n" "$ts" "$event" "$details"
        done
    fi
}

# Show current step for a worker
cmd_step() {
    local pattern="$1"
    local worker_dir
    worker_dir=$(find_worker "$pattern") || exit 1

    local step_file="$worker_dir/step-config.json"
    if [ ! -f "$step_file" ]; then
        echo "No step config found for worker" >&2
        exit 1
    fi

    echo -e "${BOLD}Current Step:${NC} $(basename "$worker_dir")"
    echo ""

    if [ "$JSON_OUTPUT" = true ]; then
        cat "$step_file"
    else
        jq -r 'to_entries[] | "  \(.key): \(.value)"' "$step_file"
    fi

    # Show gate result if exists
    local gate_file="$worker_dir/gate_result"
    if [ -f "$gate_file" ]; then
        echo ""
        local result
        result=$(cat "$gate_file")
        local color="$NC"
        case "$result" in
            PASS) color="$GREEN" ;;
            FAIL) color="$RED" ;;
            FIX)  color="$YELLOW" ;;
            STOP) color="$RED" ;;
        esac
        echo -e "${BOLD}Gate Result:${NC} ${color}${result}${NC}"
    fi
}

# Global options
JSON_OUTPUT=false
LINES_COUNT=20
COMMAND=""
ARGS=()

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit $EXIT_OK
            ;;
        --json)
            JSON_OUTPUT=true
            shift
            ;;
        -n|--lines)
            LINES_COUNT="$2"
            shift 2
            ;;
        -*)
            echo "Unknown option: $1" >&2
            show_help
            exit $EXIT_USAGE
            ;;
        *)
            if [ -z "$COMMAND" ]; then
                COMMAND="$1"
            else
                ARGS+=("$1")
            fi
            shift
            ;;
    esac
done

# Require command
if [ -z "$COMMAND" ]; then
    show_help
    exit $EXIT_OK
fi

# Check .ralph directory for commands that need it
case "$COMMAND" in
    worker|activity|step)
        if [ ! -d "$RALPH_DIR" ]; then
            echo "ERROR: .ralph/ directory not found. Run 'wiggum init' first." >&2
            exit 1
        fi
        ;;
esac

# Dispatch command
case "$COMMAND" in
    worker)
        if [ ${#ARGS[@]} -eq 0 ]; then
            echo "Usage: wiggum inspect worker <pattern>" >&2
            exit $EXIT_USAGE
        fi
        cmd_worker "${ARGS[0]}"
        ;;
    pipeline)
        cmd_pipeline "${ARGS[0]:-}"
        ;;
    agents)
        cmd_agents
        ;;
    activity)
        cmd_activity "${ARGS[0]:-}"
        ;;
    step)
        if [ ${#ARGS[@]} -eq 0 ]; then
            echo "Usage: wiggum inspect step <pattern>" >&2
            exit $EXIT_USAGE
        fi
        cmd_step "${ARGS[0]}"
        ;;
    *)
        echo "Unknown command: $COMMAND" >&2
        show_help
        exit $EXIT_USAGE
        ;;
esac
