#!/usr/bin/env bash
# wiggum stop - Stop workers or orchestrator
#
# Usage:
#   wiggum stop                 Stop all workers
#   wiggum stop <id>            Stop specific worker by ID/pattern
#   wiggum stop orchestrator    Stop the orchestrator process

set -euo pipefail

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
PROJECT_DIR="$(pwd)"
RALPH_DIR="${RALPH_DIR:-$PROJECT_DIR/.ralph}"

source "$WIGGUM_HOME/lib/core/exit-codes.sh"
source "$WIGGUM_HOME/lib/core/defaults.sh"
source "$WIGGUM_HOME/lib/worker/worker-lifecycle.sh"

show_help() {
    cat << EOF
wiggum stop - Stop workers or orchestrator

Usage:
  wiggum stop                 Stop all workers
  wiggum stop <id>            Stop specific worker by ID/pattern
  wiggum stop orchestrator    Stop the orchestrator process

Worker ID Resolution:
  Worker IDs can be partial as long as they match exactly one worker:
  - 1891712              (timestamp)
  - K-030                (partial task ID)
  - TASK-030             (task ID)
  - worker-TASK-030-1891712  (full ID)

Options:
  -h, --help    Show this help message

Examples:
  wiggum stop                 # Stop all workers
  wiggum stop TASK-030        # Stop worker for TASK-030
  wiggum stop 1891712         # Stop worker by timestamp
  wiggum stop orchestrator    # Stop the orchestrator

EOF
}

# Stop a single worker by directory
stop_single_worker() {
    local worker_dir="$1"
    local worker_id
    worker_id=$(basename "$worker_dir")

    local pid
    pid=$(get_worker_pid "$worker_dir") || return 1

    echo "Stopping worker $worker_id (PID: $pid) and children..."
    kill_process_tree "$pid" TERM

    # Wait for graceful shutdown (up to 30 seconds)
    local timeout=30
    local elapsed=0
    while kill -0 "$pid" 2>/dev/null && [ $elapsed -lt $timeout ]; do
        sleep 1
        ((elapsed++)) || true
        echo -ne "\rWaiting for worker to stop... ${elapsed}s"
    done
    echo ""

    if kill -0 "$pid" 2>/dev/null; then
        echo "Warning: Worker did not stop gracefully within ${timeout}s"
        echo "Use 'wiggum kill $worker_id' to force terminate"
        return 1
    else
        echo "Worker $worker_id stopped successfully"
        rm -f "$worker_dir/agent.pid"
    fi
}

# Stop all workers
stop_all_workers() {
    # Check for active workers by scanning worker directories
    if [ ! -d "$RALPH_DIR/workers" ]; then
        echo "No wiggum workers found"
        exit $EXIT_OK
    fi

    # Collect active workers using shared library
    declare -A worker_pids_map=()  # pid -> worker_id (initialize empty)
    while read -r pid _task_id worker_id; do
        [ -n "$pid" ] || continue
        worker_pids_map[$pid]="$worker_id"
    done < <(scan_active_workers "$RALPH_DIR")

    # Check if any workers are running
    if [ "${#worker_pids_map[@]}" -eq 0 ]; then
        echo "No wiggum workers running"
        exit $EXIT_OK
    fi

    echo "Stopping all workers..."

    # Get all running PIDs
    declare -a all_pids=()
    for pid in "${!worker_pids_map[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            all_pids+=("$pid")
        fi
    done

    # Stop the workers
    local timeout=10

    # Send TERM signal to all workers
    for pid in "${all_pids[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            echo "Stopping ${worker_pids_map[$pid]} (PID $pid) and children"
            kill_process_tree "$pid" TERM
        fi
    done

    # Wait for workers to stop
    echo "Waiting for workers to terminate..."
    local elapsed=0
    local all_stopped=false

    while [ $elapsed -lt $timeout ]; do
        all_stopped=true
        for pid in "${all_pids[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                all_stopped=false
                break
            fi
        done

        if [ "$all_stopped" = true ]; then
            break
        fi

        sleep 1
        ((elapsed++)) || true
    done

    # Force kill any remaining workers
    if [ "$all_stopped" = false ]; then
        echo "Warning: Some workers did not stop gracefully, force killing..."
        for pid in "${all_pids[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                echo "Force killing ${worker_pids_map[$pid]} (PID $pid) and children"
                kill_process_tree "$pid" KILL
            fi
        done
        sleep 1
    fi

    # Count successfully stopped workers
    local stopped_count=0
    for pid in "${all_pids[@]}"; do
        if ! kill -0 "$pid" 2>/dev/null; then
            ((stopped_count++)) || true
        fi
    done

    echo "Stopped $stopped_count workers"
}

# Stop the orchestrator
stop_orchestrator() {
    local orchestrator_lock="$RALPH_DIR/.orchestrator.pid"

    if [ ! -f "$orchestrator_lock" ]; then
        echo "No orchestrator process running"
        exit $EXIT_OK
    fi

    local orchestrator_pid
    orchestrator_pid=$(cat "$orchestrator_lock" 2>/dev/null)

    # Validate PID is a number
    if ! [[ "$orchestrator_pid" =~ ^[0-9]+$ ]]; then
        echo "Invalid orchestrator PID, cleaning lock file"
        rm -f "$orchestrator_lock"
        exit $EXIT_OK
    fi

    # Check if process is running and is wiggum-run
    if kill -0 "$orchestrator_pid" 2>/dev/null; then
        if ps -p "$orchestrator_pid" -o args= 2>/dev/null | grep -q "wiggum-run"; then
            echo "Stopping orchestrator (PID: $orchestrator_pid)..."
            kill -TERM "$orchestrator_pid"
            echo "Orchestrator stopped"
            exit $EXIT_OK
        else
            echo "Process $orchestrator_pid is not wiggum-run (PID reused?)"
            rm -f "$orchestrator_lock"
            exit $EXIT_OK
        fi
    else
        echo "Orchestrator process not running, cleaning stale lock"
        rm -f "$orchestrator_lock"
        exit $EXIT_OK
    fi
}

# Main
main() {
    # Handle help
    if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
        show_help
        exit $EXIT_OK
    fi

    # No arguments = stop all workers
    if [ $# -eq 0 ]; then
        stop_all_workers
        exit $EXIT_OK
    fi

    local target="$1"
    shift

    # Check for special target: orchestrator
    if [ "$target" = "orchestrator" ]; then
        stop_orchestrator  # This function always exits
    fi

    # Otherwise, treat as worker ID pattern
    local worker_dir
    worker_dir=$(resolve_worker_id "$RALPH_DIR" "$target") || exit $EXIT_ERROR

    stop_single_worker "$worker_dir"
}

main "$@"
