#!/usr/bin/env bash
# wiggum resume - Resume a stopped worker
#
# Usage:
#   wiggum resume <id>        Resume a previously stopped worker
#   wiggum resume <id> -f     Force resume, clearing violation status

set -euo pipefail

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
PROJECT_DIR="$(pwd)"
RALPH_DIR="$PROJECT_DIR/.ralph"

source "$WIGGUM_HOME/lib/core/exit-codes.sh"
source "$WIGGUM_HOME/lib/core/logger.sh"
source "$WIGGUM_HOME/lib/tasks/task-parser.sh"
source "$WIGGUM_HOME/lib/metrics/audit-logger.sh"
source "$WIGGUM_HOME/lib/worker/worker-lifecycle.sh"
source "$WIGGUM_HOME/lib/worker/agent-registry.sh"
source "$WIGGUM_HOME/lib/agents/validation-review.sh"
source "$WIGGUM_HOME/lib/git/git-operations.sh"
source "$WIGGUM_HOME/lib/core/file-lock.sh"

# Default configuration (can be overridden by env vars)
MAX_ITERATIONS="${WIGGUM_MAX_ITERATIONS:-20}"
MAX_TURNS="${WIGGUM_MAX_TURNS:-50}"

show_help() {
    cat << EOF
wiggum resume - Resume a stopped worker

Usage:
  wiggum resume <id>        Resume a previously stopped worker
  wiggum resume <id> -f     Force resume, clearing violation status

Worker ID Resolution:
  Worker IDs can be partial as long as they match exactly one worker:
  - 1891712              (timestamp)
  - K-030                (partial task ID)
  - TASK-030             (task ID)
  - worker-TASK-030-1891712  (full ID)

Options:
  -f            Force resume, clearing any workspace violation status.
                Use this after manually resolving violations.
  -h, --help    Show this help message

Examples:
  wiggum resume TASK-030        # Resume worker for TASK-030
  wiggum resume 1891712         # Resume worker by timestamp
  wiggum resume TASK-030 -f     # Force resume after fixing violations

EOF
}

# Determine which iteration to resume from
determine_resume_iteration() {
    local worker_dir="$1"
    local logs_dir="$worker_dir/logs"
    local max_iter=-1

    # Find the highest iteration number
    if [ -d "$logs_dir" ]; then
        for log_file in "$logs_dir"/iteration-*.log; do
            [ -f "$log_file" ] || continue
            local iter
            iter=$(basename "$log_file" | sed 's/iteration-\([0-9]*\).log/\1/')
            if [ "$iter" -gt "$max_iter" ]; then
                max_iter=$iter
            fi
        done
    fi

    if [ "$max_iter" -lt 0 ]; then
        # No iterations found, start from 0
        echo "0"
        return
    fi

    # If N has summary, resume from N+1; else redo N
    if [ -f "$worker_dir/summaries/iteration-${max_iter}-summary.txt" ]; then
        echo "$((max_iter + 1))"
    else
        echo "$max_iter"
    fi
}

# Prepare context for resume
prepare_resume_context() {
    local worker_dir="$1"
    local resume_iter="$2"

    if [ "$resume_iter" -gt 0 ]; then
        local prev_iter=$((resume_iter - 1))
        local prev_summary="$worker_dir/summaries/iteration-${prev_iter}-summary.txt"

        if [ -f "$prev_summary" ]; then
            # Use the previous summary as context
            cp "$prev_summary" "$worker_dir/resume-context.md"
            echo "Using summary from iteration $prev_iter as context"
        else
            # No summary available, try to generate from log
            local prev_log="$worker_dir/logs/iteration-${prev_iter}.log"
            if [ -f "$prev_log" ]; then
                echo "Converting iteration $prev_iter log to markdown..."
                "$WIGGUM_HOME/lib/log-converter.sh" "$prev_log" "$worker_dir/resume-context.md"
            else
                echo "Warning: No context available for resume (starting fresh)"
                touch "$worker_dir/resume-context.md"
            fi
        fi
    else
        # Starting from iteration 0, no context needed
        touch "$worker_dir/resume-context.md"
    fi
}

# Resume from validation phase (summary.txt exists, work is complete)
# Runs validation review, then commits and creates PR if passed
resume_from_validation() {
    local worker_dir="$1"
    local task_id="$2"

    # Mark task as in-progress before running validation
    update_kanban_status "$PROJECT_DIR/.ralph/kanban.md" "$task_id" "="

    # Run validation-review as top-level agent (handles PID internally)
    # Note: using 0 for monitor_interval since validation is quick and read-only
    run_agent "validation-review" "$worker_dir" "$PROJECT_DIR" 0 10

    # Check validation result
    if ! check_validation_result "$worker_dir"; then
        local result
        result=$(cat "$worker_dir/validation-result.txt" 2>/dev/null || echo "UNKNOWN")
        echo "Validation $result - cannot proceed with commit/PR"
        # Mark task as failed in kanban
        update_kanban_failed "$PROJECT_DIR/.ralph/kanban.md" "$task_id"
        return 1
    fi

    echo "Validation PASSED - creating commit and PR..."

    # Use shared library for git operations
    if git_finalize_worker "$worker_dir" "$task_id" "$PROJECT_DIR"; then
        echo "PR URL: $GIT_PR_URL"

        # If PR was created, mark as Pending Approval [P] - wiggum review sync will mark [x] when merged
        # If no PR (gh CLI unavailable), mark as complete [x] directly
        if [ -n "$GIT_PR_URL" ] && [ "$GIT_PR_URL" != "N/A" ]; then
            if update_kanban_pending_approval "$PROJECT_DIR/.ralph/kanban.md" "$task_id"; then
                echo "Task $task_id marked as pending approval [P] in kanban"
            fi
        else
            if update_kanban "$PROJECT_DIR/.ralph/kanban.md" "$task_id"; then
                echo "Task $task_id marked as complete [x] in kanban (no PR)"
            fi
        fi

        return 0
    else
        echo "Failed to create commit/PR"
        update_kanban_failed "$PROJECT_DIR/.ralph/kanban.md" "$task_id"
        return 1
    fi
}

# Resume a stopped worker
do_resume() {
    local worker_dir="$1"
    local force_mode="${2:-false}"
    local worker_id
    worker_id=$(basename "$worker_dir")
    local task_id
    task_id=$(echo "$worker_id" | sed -E 's/worker-(TASK-[0-9]+)-.*/\1/')

    # Check if already running
    if [ -f "$worker_dir/agent.pid" ]; then
        local existing_pid
        existing_pid=$(cat "$worker_dir/agent.pid" 2>/dev/null)
        if kill -0 "$existing_pid" 2>/dev/null; then
            echo "Error: Worker $worker_id is already running (PID: $existing_pid)"
            exit $EXIT_ERROR
        fi
    fi

    # Check main repo is clean (prevents workspace violations)
    local dirty_files
    dirty_files=$(cd "$PROJECT_DIR" && git status --porcelain 2>/dev/null | grep -v "^.. .ralph/" || true)
    if [ -n "$dirty_files" ]; then
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "MAIN REPO HAS UNCOMMITTED CHANGES"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""
        echo "Cannot resume worker - main repository has uncommitted changes:"
        echo "$dirty_files" | head -10
        echo ""
        echo "This would cause workspace boundary violations."
        echo "Please commit or stash your changes first."
        echo ""
        exit $EXIT_ERROR
    fi

    # Check for workspace violations
    if [ -f "$worker_dir/violation_status.txt" ]; then
        local violation_status
        violation_status=$(cat "$worker_dir/violation_status.txt" 2>/dev/null)
        if [ "$violation_status" = "WORKSPACE_VIOLATION" ]; then
            if [ "$force_mode" = "true" ]; then
                echo "Warning: Clearing workspace violation status (forced)"
                rm -f "$worker_dir/violation_status.txt"
            else
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "WORKSPACE VIOLATION DETECTED"
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo ""
                echo "This worker was previously stopped due to a workspace violation."
                echo "Files were modified outside the worker's isolated workspace."
                echo ""
                echo "Before resuming, you should:"
                echo "  1. Review the violation log: $RALPH_DIR/logs/violations.log"
                echo "  2. Ensure no uncommitted changes exist in the main repo"
                echo "  3. Manually inspect $worker_dir/workspace for issues"
                echo ""
                echo "To force resume (clears violation status):"
                echo "  wiggum resume $worker_id -f"
                echo ""
                exit $EXIT_ERROR
            fi
        fi
    fi

    # Check PRD exists
    if [ ! -f "$worker_dir/prd.md" ]; then
        echo "Error: PRD not found at $worker_dir/prd.md"
        exit $EXIT_ERROR
    fi

    # Check workspace exists
    if [ ! -d "$worker_dir/workspace" ]; then
        echo "Error: Workspace not found at $worker_dir/workspace"
        echo "The worktree may have been cleaned up."
        exit $EXIT_ERROR
    fi

    # Check if summary.txt exists - work is complete, run validation/finalize
    if [ -f "$worker_dir/summaries/summary.txt" ]; then
        echo "Summary found - work is complete, running validation and finalization..."
        resume_from_validation "$worker_dir" "$task_id"
        return $?
    fi

    # Determine resume iteration
    local resume_iteration
    resume_iteration=$(determine_resume_iteration "$worker_dir")

    echo "Resuming worker $worker_id for task $task_id"
    echo "Starting from iteration $resume_iteration"

    # Prepare context for resume
    prepare_resume_context "$worker_dir" "$resume_iteration"

    # Launch task-worker agent with resume context
    export WORKER_ID="$worker_id"
    export TASK_ID="$task_id"
    export WIGGUM_HOME
    export WIGGUM_MAX_ITERATIONS="$MAX_ITERATIONS"
    export WIGGUM_MAX_TURNS="$MAX_TURNS"
    export WIGGUM_RESUME_ITERATION="$resume_iteration"
    export WIGGUM_RESUME_CONTEXT="$worker_dir/resume-context.md"

    mkdir -p "$RALPH_DIR/logs"
    (
        # Run agent in subshell to isolate it
        run_agent "task-worker" "$worker_dir" "$PROJECT_DIR"
    ) >> "$RALPH_DIR/logs/workers.log" 2>&1 &

    # Wait briefly for agent.pid to be created
    local wait_count=0
    while [ ! -f "$worker_dir/agent.pid" ] && [ $wait_count -lt 10 ]; do
        sleep 0.1
        ((wait_count++)) || true
    done

    if [ -f "$worker_dir/agent.pid" ]; then
        local worker_pid
        worker_pid=$(cat "$worker_dir/agent.pid")
        echo "Worker running (PID: $worker_pid)"
    else
        echo "Worker started (PID file pending)"
    fi
    echo "Use 'wiggum monitor' to follow progress"
}

# Main
main() {
    local force_mode=false
    local target=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit $EXIT_OK
                ;;
            -f)
                force_mode=true
                shift
                ;;
            -*)
                echo "Unknown option: $1"
                show_help
                exit $EXIT_USAGE
                ;;
            *)
                if [ -z "$target" ]; then
                    target="$1"
                else
                    echo "Unexpected argument: $1"
                    exit $EXIT_USAGE
                fi
                shift
                ;;
        esac
    done

    # Require target
    if [ -z "$target" ]; then
        echo "Error: Worker ID required"
        echo "Usage: wiggum resume <id> [-f]"
        exit $EXIT_USAGE
    fi

    # Resolve worker directory
    local worker_dir
    worker_dir=$(resolve_worker_id "$RALPH_DIR" "$target") || exit $EXIT_ERROR

    do_resume "$worker_dir" "$force_mode"
}

main "$@"
