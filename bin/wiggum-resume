#!/usr/bin/env bash
# wiggum resume - Resume a stopped worker using LLM-driven step decision
#
# Usage:
#   wiggum resume <id>        Resume a previously stopped worker
#   wiggum resume <id> -f     Force resume, clearing violation status

set -euo pipefail

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
PROJECT_DIR="$(pwd)"
RALPH_DIR="$PROJECT_DIR/.ralph"

source "$WIGGUM_HOME/lib/core/exit-codes.sh"
source "$WIGGUM_HOME/lib/core/logger.sh"
source "$WIGGUM_HOME/lib/tasks/task-parser.sh"
source "$WIGGUM_HOME/lib/utils/audit-logger.sh"
source "$WIGGUM_HOME/lib/worker/worker-lifecycle.sh"
source "$WIGGUM_HOME/lib/worker/agent-registry.sh"
source "$WIGGUM_HOME/lib/core/agent-base.sh"
source "$WIGGUM_HOME/lib/git/git-operations.sh"
source "$WIGGUM_HOME/lib/core/file-lock.sh"
source "$WIGGUM_HOME/lib/claude/usage-tracker.sh"

# Default configuration
MAX_ITERATIONS=20
MAX_TURNS=50

show_help() {
    cat << EOF
wiggum resume - Resume a stopped worker

Usage:
  wiggum resume <id>        Resume a previously stopped worker
  wiggum resume <id> -f     Force resume, clearing violation status

The resume process:
  1. Converts worker logs to readable conversation format
  2. Runs an LLM agent to analyze what happened and decide the resume step
  3. Archives previous run artifacts (workspace is preserved)
  4. Launches a fresh task-worker from the decided step

Resume Steps (in order):
  execution     - Restart the main work loop from scratch
  audit         - Resume from security audit phase
  test          - Resume from test coverage phase
  docs          - Resume from documentation phase
  validation    - Resume from validation review phase
  finalization  - Resume from commit/PR creation phase

Worker ID Resolution:
  Worker IDs can be partial as long as they match exactly one worker:
  - 1891712              (timestamp)
  - K-030                (partial task ID)
  - TASK-030             (task ID)
  - worker-TASK-030-1891712  (full ID)

Options:
  --max-iters N  Maximum iterations per worker (default: 20)
  --max-turns N  Maximum turns per Claude session (default: 50)
  -f             Force resume, clearing any workspace violation status.
                 Use this after manually resolving violations.
  -h, --help     Show this help message

Examples:
  wiggum resume TASK-030        # Resume worker for TASK-030
  wiggum resume 1891712         # Resume worker by timestamp
  wiggum resume TASK-030 -f     # Force resume after fixing violations

EOF
}

# Archive previous run artifacts before resuming
# Moves logs, summaries, checkpoints, conversations, etc. to history/
# Workspace is LEFT UNTOUCHED (it has the actual code changes)
archive_previous_run() {
    local worker_dir="$1"
    local archive_dir
    archive_dir="$worker_dir/history/resume-$(date +%s)"

    mkdir -p "$archive_dir"

    # Move all run artifacts — workspace/ is LEFT UNTOUCHED
    mv "$worker_dir/logs" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/summaries" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/checkpoints" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/conversations" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/supervisors" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/worker.log" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/results" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/reports" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/agent-result.json" "$archive_dir/" 2>/dev/null || true
    # reports/resume-instructions.md stays — needed by the resumed worker
    if [ -d "$archive_dir/reports" ] && [ -f "$archive_dir/reports/resume-instructions.md" ]; then
        mkdir -p "$worker_dir/reports"
        mv "$archive_dir/reports/resume-instructions.md" "$worker_dir/reports/"
    fi

    echo "Archived previous run to $(basename "$archive_dir")"
}

# Resume a stopped worker
do_resume() {
    local worker_dir="$1"
    local force_mode="${2:-false}"
    local worker_id
    worker_id=$(basename "$worker_dir")
    local task_id
    # Match any task prefix format: TASK-001, PIPELINE-001, etc.
    task_id=$(echo "$worker_id" | sed -E 's/worker-([A-Z]+-[0-9]+)-.*/\1/')

    # Check if already running
    if [ -f "$worker_dir/agent.pid" ]; then
        local existing_pid
        existing_pid=$(cat "$worker_dir/agent.pid" 2>/dev/null)
        if kill -0 "$existing_pid" 2>/dev/null; then
            echo "Error: Worker $worker_id is already running (PID: $existing_pid)"
            exit $EXIT_ERROR
        fi
    fi

    # Check main repo is clean (prevents workspace violations)
    local dirty_files
    dirty_files=$(cd "$PROJECT_DIR" && git status --porcelain 2>/dev/null | grep -v "^.. .ralph/" || true)
    if [ -n "$dirty_files" ]; then
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "MAIN REPO HAS UNCOMMITTED CHANGES"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""
        echo "Cannot resume worker - main repository has uncommitted changes:"
        echo "$dirty_files" | head -10
        echo ""
        echo "This would cause workspace boundary violations."
        echo "Please commit or stash your changes first."
        echo ""
        exit $EXIT_ERROR
    fi

    # Check for workspace violations
    if [ -f "$worker_dir/violation_status.txt" ]; then
        local violation_status
        violation_status=$(cat "$worker_dir/violation_status.txt" 2>/dev/null)
        if [ "$violation_status" = "WORKSPACE_VIOLATION" ]; then
            if [ "$force_mode" = "true" ]; then
                echo "Warning: Clearing workspace violation status (forced)"
                rm -f "$worker_dir/violation_status.txt"
            else
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "WORKSPACE VIOLATION DETECTED"
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo ""
                echo "This worker was previously stopped due to a workspace violation."
                echo "Files were modified outside the worker's isolated workspace."
                echo ""
                echo "Before resuming, you should:"
                echo "  1. Review the violation log: $RALPH_DIR/logs/violations.log"
                echo "  2. Ensure no uncommitted changes exist in the main repo"
                echo "  3. Manually inspect $worker_dir/workspace for issues"
                echo ""
                echo "To force resume (clears violation status):"
                echo "  wiggum resume $worker_id -f"
                echo ""
                exit $EXIT_ERROR
            fi
        fi
    fi

    # Check PRD exists
    if [ ! -f "$worker_dir/prd.md" ]; then
        echo "Error: PRD not found at $worker_dir/prd.md"
        exit $EXIT_ERROR
    fi

    # Check workspace exists
    if [ ! -d "$worker_dir/workspace" ]; then
        echo "Error: Workspace not found at $worker_dir/workspace"
        echo "The worktree may have been cleaned up."
        exit $EXIT_ERROR
    fi

    echo "Resuming worker $worker_id for task $task_id"
    echo ""

    # === STEP 1: Convert logs to conversations ===
    echo "Converting logs to readable conversations..."
    if [ -d "$worker_dir/logs" ]; then
        "$WIGGUM_HOME/lib/utils/log-converter.sh" --dir "$worker_dir"
    else
        echo "  No logs directory found — starting fresh"
        mkdir -p "$worker_dir/conversations"
        # Create a minimal worker.log so resume-decide has something to read
        if [ ! -f "$worker_dir/worker.log" ]; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Worker was interrupted before producing logs" > "$worker_dir/worker.log"
        fi
    fi

    # === STEP 2: Run resume-decide agent ===
    echo "Analyzing previous run to decide resume step..."
    run_agent "resume-decide" "$worker_dir" "$PROJECT_DIR" 0 1 25

    # === STEP 3: Read decision ===
    local resume_step
    resume_step=$(cat "$worker_dir/resume-step.txt" 2>/dev/null || echo "ABORT")
    resume_step=$(echo "$resume_step" | tr -d '[:space:]')

    if [ "$resume_step" = "ABORT" ]; then
        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "RESUME ABORTED"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""
        if [ -f "$worker_dir/reports/resume-instructions.md" ]; then
            echo "Reason:"
            cat "$worker_dir/reports/resume-instructions.md"
        fi
        echo ""
        exit $EXIT_ERROR
    fi

    # Validate step is one of the known values
    case "$resume_step" in
        execution|audit|test|docs|validation|finalization)
            ;;
        *)
            echo "Error: Invalid resume step '$resume_step' (expected: execution, audit, test, docs, validation, finalization)"
            exit $EXIT_ERROR
            ;;
    esac

    echo "Resume decision: start from '$resume_step' step"
    echo ""

    # === STEP 4: Archive old artifacts ===
    archive_previous_run "$worker_dir"

    # === STEP 5: Re-create required directories ===
    mkdir -p "$worker_dir/logs" "$worker_dir/summaries"

    # === STEP 6: Check rate limit before launching ===
    # Update usage data and check rate limit (orchestrator may not be running)
    usage_tracker_write_shared "$RALPH_DIR" > /dev/null 2>&1 || true
    if rate_limit_check "$RALPH_DIR"; then
        log "Rate limit threshold reached - waiting for cycle reset before resuming"
        rate_limit_wait_for_cycle_reset
        usage_tracker_write_shared "$RALPH_DIR" > /dev/null 2>&1 || true
    fi

    # === STEP 7: Launch task-worker ===
    # Always use normal task-worker (not plan-mode) — it picks up existing plan files
    echo "Launching task-worker from step: $resume_step"

    mkdir -p "$RALPH_DIR/logs"
    (
        # Run agent in subshell to isolate it
        run_agent "task-worker" "$worker_dir" "$PROJECT_DIR" 30 "$MAX_ITERATIONS" "$MAX_TURNS" \
            "$resume_step" "$worker_dir/reports/resume-instructions.md"
    ) >> "$RALPH_DIR/logs/workers.log" 2>&1 &

    # Wait briefly for agent.pid to be created
    local wait_count=0
    while [ ! -f "$worker_dir/agent.pid" ] && [ $wait_count -lt 10 ]; do
        sleep 0.1
        ((wait_count++)) || true
    done

    if [ -f "$worker_dir/agent.pid" ]; then
        local worker_pid
        worker_pid=$(cat "$worker_dir/agent.pid")
        echo "Worker running (PID: $worker_pid)"
    else
        echo "Worker started (PID file pending)"
    fi
    echo "Use 'wiggum monitor' to follow progress"
}

# Main
main() {
    local force_mode=false
    local target=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit $EXIT_OK
                ;;
            -f)
                force_mode=true
                shift
                ;;
            --max-iters)
                if [[ -z "${2:-}" ]] || [[ "${2:-}" =~ ^- ]]; then
                    echo "Error: --max-iters requires a number argument"
                    exit $EXIT_USAGE
                fi
                MAX_ITERATIONS="$2"
                shift 2
                ;;
            --max-turns)
                if [[ -z "${2:-}" ]] || [[ "${2:-}" =~ ^- ]]; then
                    echo "Error: --max-turns requires a number argument"
                    exit $EXIT_USAGE
                fi
                MAX_TURNS="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1"
                show_help
                exit $EXIT_USAGE
                ;;
            *)
                if [ -z "$target" ]; then
                    target="$1"
                else
                    echo "Unexpected argument: $1"
                    exit $EXIT_USAGE
                fi
                shift
                ;;
        esac
    done

    # Load rate limit configuration
    load_rate_limit_config

    # Require target
    if [ -z "$target" ]; then
        echo "Error: Worker ID required"
        echo "Usage: wiggum resume <id> [-f]"
        exit $EXIT_USAGE
    fi

    # Resolve worker directory
    local worker_dir
    worker_dir=$(resolve_worker_id "$RALPH_DIR" "$target") || exit $EXIT_ERROR

    do_resume "$worker_dir" "$force_mode"
}

main "$@"
