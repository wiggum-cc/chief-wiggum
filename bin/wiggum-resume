#!/usr/bin/env bash
# wiggum resume - Resume a stopped worker using LLM-driven step decision
#
# Usage:
#   wiggum resume <id>        Resume a previously stopped worker
#   wiggum resume <id> -f     Force resume, clearing violation status

set -euo pipefail

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
PROJECT_DIR="$(pwd)"
RALPH_DIR="${RALPH_DIR:-$PROJECT_DIR/.ralph}"

source "$WIGGUM_HOME/lib/core/exit-codes.sh"
source "$WIGGUM_HOME/lib/core/defaults.sh"
source "$WIGGUM_HOME/lib/core/logger.sh"
source "$WIGGUM_HOME/lib/tasks/task-parser.sh"
source "$WIGGUM_HOME/lib/utils/audit-logger.sh"
source "$WIGGUM_HOME/lib/worker/worker-lifecycle.sh"
source "$WIGGUM_HOME/lib/worker/agent-registry.sh"
source "$WIGGUM_HOME/lib/core/agent-base.sh"
source "$WIGGUM_HOME/lib/git/git-operations.sh"
source "$WIGGUM_HOME/lib/core/file-lock.sh"
source "$WIGGUM_HOME/lib/claude/usage-tracker.sh"
source "$WIGGUM_HOME/lib/pipeline/pipeline-loader.sh"

# Default configuration
MAX_ITERATIONS=20
MAX_TURNS=50

show_help() {
    cat << EOF
wiggum resume - Resume a stopped worker

Usage:
  wiggum resume <id>        Resume a previously stopped worker
  wiggum resume <id> -f     Force resume, clearing violation status

The resume process:
  1. Converts worker logs to readable conversation format
  2. Runs an LLM agent to analyze what happened and decide the resume step
  3. Archives previous run artifacts (workspace is preserved)
  4. Launches a fresh system.task-worker from the decided step

Resume Steps:
  Steps are loaded dynamically from the pipeline config (config/pipeline.json
  or .ralph/pipeline.json). The LLM decides which step to resume from based
  on its analysis of the previous run. Common steps in the default pipeline:
    planning, execution, summary, audit, test, docs, validation

Worker ID Resolution:
  Worker IDs can be partial as long as they match exactly one worker:
  - 1891712              (timestamp)
  - K-030                (partial task ID)
  - TASK-030             (task ID)
  - worker-TASK-030-1891712  (full ID)

Options:
  --max-iters N  Maximum iterations per worker (default: 20)
  --max-turns N  Maximum turns per Claude session (default: 50)
  -f             Force resume, clearing any workspace violation status.
                 Use this after manually resolving violations.
  -h, --help     Show this help message

Examples:
  wiggum resume TASK-030        # Resume worker for TASK-030
  wiggum resume 1891712         # Resume worker by timestamp
  wiggum resume TASK-030 -f     # Force resume after fixing violations

EOF
}

# Archive previous run artifacts before resuming
# Moves logs, summaries, checkpoints, conversations, etc. to history/
# Workspace and results/ are LEFT UNTOUCHED:
#   - workspace/ has the actual code changes
#   - results/ has epoch-named result files needed for parent context on resume
archive_previous_run() {
    local worker_dir="$1"
    local archive_dir
    archive_dir="$worker_dir/history/resume-$(date +%s)"

    mkdir -p "$archive_dir"

    # Move run artifacts — workspace/ and results/ are LEFT UNTOUCHED
    # results/ is preserved so _export_step_context() can find parent step output
    mv "$worker_dir/logs" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/summaries" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/checkpoints" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/conversations" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/supervisors" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/worker.log" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/reports" "$archive_dir/" 2>/dev/null || true
    mv "$worker_dir/agent-result.json" "$archive_dir/" 2>/dev/null || true
    # Preserve the latest resume-decide report — needed by the resumed worker via {{parent.report}}
    if [ -d "$archive_dir/reports" ]; then
        local resume_report
        resume_report=$(find_newest "$archive_dir/reports" -maxdepth 1 -name "*-system.resume-decide-report.md")
        if [ -n "$resume_report" ] && [ -f "$resume_report" ]; then
            mkdir -p "$worker_dir/reports"
            mv "$resume_report" "$worker_dir/reports/"
        fi
    fi

    echo "Archived previous run to $(basename "$archive_dir")"
}

# Resume a stopped worker
do_resume() {
    local worker_dir="$1"
    local force_mode="${2:-false}"
    local worker_id
    worker_id=$(basename "$worker_dir")
    local task_id
    # Match any task prefix format: TASK-001, PIPELINE-001, etc.
    task_id=$(echo "$worker_id" | sed -E 's/worker-([A-Za-z]{2,10}-[0-9]{1,4})-.*/\1/')

    # Check if already running
    if [ -f "$worker_dir/agent.pid" ]; then
        local existing_pid
        existing_pid=$(cat "$worker_dir/agent.pid" 2>/dev/null)
        if kill -0 "$existing_pid" 2>/dev/null; then
            echo "Error: Worker $worker_id is already running (PID: $existing_pid)"
            exit $EXIT_ERROR
        fi
    fi

    # Check main repo is clean (prevents workspace violations)
    local dirty_files
    dirty_files=$(cd "$PROJECT_DIR" && git status --porcelain 2>/dev/null | grep -v "^.. .ralph/" || true)
    if [ -n "$dirty_files" ]; then
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "MAIN REPO HAS UNCOMMITTED CHANGES"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""
        echo "Cannot resume worker - main repository has uncommitted changes:"
        echo "$dirty_files" | head -10
        echo ""
        echo "This would cause workspace boundary violations."
        echo "Please commit or stash your changes first."
        echo ""
        exit $EXIT_ERROR
    fi

    # Check for workspace violations
    if [ -f "$worker_dir/violation_status.txt" ]; then
        local violation_status
        violation_status=$(cat "$worker_dir/violation_status.txt" 2>/dev/null)
        if [ "$violation_status" = "WORKSPACE_VIOLATION" ]; then
            if [ "$force_mode" = "true" ]; then
                echo "Warning: Clearing workspace violation status (forced)"
                rm -f "$worker_dir/violation_status.txt"
            else
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "WORKSPACE VIOLATION DETECTED"
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo ""
                echo "This worker was previously stopped due to a workspace violation."
                echo "Files were modified outside the worker's isolated workspace."
                echo ""
                echo "Before resuming, you should:"
                echo "  1. Review the violation log: $RALPH_DIR/logs/violations.log"
                echo "  2. Ensure no uncommitted changes exist in the main repo"
                echo "  3. Manually inspect $worker_dir/workspace for issues"
                echo ""
                echo "To force resume (clears violation status):"
                echo "  wiggum resume $worker_id -f"
                echo ""
                exit $EXIT_ERROR
            fi
        fi
    fi

    # Check PRD exists
    if [ ! -f "$worker_dir/prd.md" ]; then
        echo "Error: PRD not found at $worker_dir/prd.md"
        exit $EXIT_ERROR
    fi

    # Check workspace exists
    if [ ! -d "$worker_dir/workspace" ]; then
        echo "Error: Workspace not found at $worker_dir/workspace"
        echo "The worktree may have been cleaned up."
        exit $EXIT_ERROR
    fi

    echo "Resuming worker $worker_id for task $task_id"
    echo ""

    # === STEP 1: Convert logs to conversations ===
    echo "Converting logs to readable conversations..."
    if [ -d "$worker_dir/logs" ]; then
        "$WIGGUM_HOME/lib/utils/log-converter.sh" --dir "$worker_dir"
    else
        echo "  No logs directory found — starting fresh"
        mkdir -p "$worker_dir/conversations"
        # Create a minimal worker.log so system.resume-decide has something to read
        if [ ! -f "$worker_dir/worker.log" ]; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Worker was interrupted before producing logs" > "$worker_dir/worker.log"
        fi
    fi

    # === STEP 2: Run system.resume-decide agent ===
    echo "Analyzing previous run to decide resume step..."
    run_agent "system.resume-decide" "$worker_dir" "$PROJECT_DIR" 0 1 25

    # === STEP 3: Read decision ===
    local resume_step
    resume_step=$(cat "$worker_dir/resume-step.txt" 2>/dev/null || echo "ABORT")
    resume_step=$(echo "$resume_step" | tr -d '[:space:]')

    if [ "$resume_step" = "ABORT" ]; then
        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "RESUME ABORTED"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""
        local abort_report
        abort_report=$(agent_find_latest_report "$worker_dir" "system.resume-decide")
        if [ -n "$abort_report" ] && [ -f "$abort_report" ]; then
            echo "Reason:"
            cat "$abort_report"
        fi
        echo ""
        exit $EXIT_ERROR
    fi

    # === STEP 3b: Load pipeline config ===
    # Load the pipeline to validate the resume step against actual step IDs
    local pipeline_file
    pipeline_file=$(pipeline_resolve "$PROJECT_DIR" "$task_id" "${WIGGUM_PIPELINE:-}")
    if [ -n "$pipeline_file" ]; then
        pipeline_load "$pipeline_file" || {
            echo "Error: Failed to load pipeline config: $pipeline_file"
            exit $EXIT_ERROR
        }
    else
        pipeline_load_builtin_defaults
    fi

    # Validate step exists in pipeline
    local step_idx
    step_idx=$(pipeline_find_step_index "$resume_step")
    if [ "$step_idx" = "-1" ]; then
        # Build list of valid step IDs for error message
        local valid_steps=""
        local count
        count=$(pipeline_step_count)
        for ((i=0; i<count; i++)); do
            local sid
            sid=$(pipeline_get "$i" ".id")
            if [ -n "$valid_steps" ]; then
                valid_steps="$valid_steps, $sid"
            else
                valid_steps="$sid"
            fi
        done
        echo "Error: Invalid resume step '$resume_step'"
        echo "Valid steps from pipeline '$PIPELINE_NAME': $valid_steps"
        exit $EXIT_ERROR
    fi

    echo "Resume decision: start from '$resume_step' step (index $step_idx)"
    echo ""

    # === STEP 4: Archive old artifacts ===
    archive_previous_run "$worker_dir"

    # === STEP 5: Re-create required directories ===
    mkdir -p "$worker_dir/logs" "$worker_dir/summaries"

    # === STEP 6: Check rate limit before launching ===
    # Update usage data and check rate limit (orchestrator may not be running)
    usage_tracker_write_shared "$RALPH_DIR" > /dev/null 2>&1 || true
    if rate_limit_check "$RALPH_DIR"; then
        log "Rate limit threshold reached - waiting for cycle reset before resuming"
        rate_limit_wait_for_cycle_reset
        usage_tracker_write_shared "$RALPH_DIR" > /dev/null 2>&1 || true
    fi

    # === STEP 7: Launch system.task-worker ===
    # Always use normal system.task-worker (not plan-mode) — it picks up existing plan files
    echo "Launching system.task-worker from step: $resume_step"

    mkdir -p "$RALPH_DIR/logs"

    # Launch agent in background using setsid to create a new session/process group.
    # This prevents SIGINT from the parent (wiggum resume) from killing the worker.
    #
    # Security: Pass variables via environment exports, not string interpolation.
    # This prevents command injection if any variable contains shell metacharacters.
    export _WORKER_WIGGUM_HOME="$WIGGUM_HOME"
    export _WORKER_DIR="$worker_dir"
    export _WORKER_PROJECT_DIR="$PROJECT_DIR"
    export _WORKER_MAX_ITERATIONS="$MAX_ITERATIONS"
    export _WORKER_MAX_TURNS="$MAX_TURNS"
    export _WORKER_RESUME_STEP="$resume_step"

    # Read report path from result file (standard mechanism)
    local resume_result_file resume_instructions_path
    resume_result_file=$(agent_find_latest_result "$worker_dir" "system.resume-decide")
    if [ -n "$resume_result_file" ] && [ -f "$resume_result_file" ]; then
        resume_instructions_path=$(jq -r '.outputs.report_file // ""' "$resume_result_file")
    fi
    export _WORKER_RESUME_INSTRUCTIONS="${resume_instructions_path:-}"

    # shellcheck disable=SC2016
    setsid bash -c '
        set -euo pipefail
        _log_ts() { echo "[$(date -Iseconds)] $*"; }
        _log_ts "INFO: Worker subprocess starting (resume)"
        _log_ts "INFO: WIGGUM_HOME=$_WORKER_WIGGUM_HOME"
        _log_ts "INFO: worker_dir=$_WORKER_DIR"
        _log_ts "INFO: resume_step=$_WORKER_RESUME_STEP"

        export WIGGUM_HOME="$_WORKER_WIGGUM_HOME"

        if ! source "$WIGGUM_HOME/lib/worker/agent-registry.sh" 2>&1; then
            _log_ts "ERROR: Failed to source agent-registry.sh"
            exit 1
        fi

        _log_ts "INFO: Running agent system.task-worker"
        if ! run_agent "system.task-worker" "$_WORKER_DIR" "$_WORKER_PROJECT_DIR" 30 "$_WORKER_MAX_ITERATIONS" "$_WORKER_MAX_TURNS" \
            "$_WORKER_RESUME_STEP" "$_WORKER_RESUME_INSTRUCTIONS"; then
            _log_ts "ERROR: run_agent failed with exit code $?"
            exit 1
        fi
    ' >> "$RALPH_DIR/logs/workers.log" 2>&1 &

    # Wait briefly for agent.pid to be created
    local wait_count=0
    while [ ! -f "$worker_dir/agent.pid" ] && [ $wait_count -lt 10 ]; do
        sleep 0.1
        ((wait_count++)) || true
    done

    if [ -f "$worker_dir/agent.pid" ]; then
        local worker_pid
        worker_pid=$(cat "$worker_dir/agent.pid")
        echo "Worker running (PID: $worker_pid)"
    else
        echo "Worker started (PID file pending)"
    fi
    echo "Use 'wiggum monitor' to follow progress"
}

# Main
main() {
    local force_mode=false
    local target=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit $EXIT_OK
                ;;
            -f)
                force_mode=true
                shift
                ;;
            --max-iters)
                if [[ -z "${2:-}" ]] || [[ "${2:-}" =~ ^- ]]; then
                    echo "Error: --max-iters requires a number argument"
                    exit $EXIT_USAGE
                fi
                MAX_ITERATIONS="$2"
                shift 2
                ;;
            --max-turns)
                if [[ -z "${2:-}" ]] || [[ "${2:-}" =~ ^- ]]; then
                    echo "Error: --max-turns requires a number argument"
                    exit $EXIT_USAGE
                fi
                MAX_TURNS="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1"
                show_help
                exit $EXIT_USAGE
                ;;
            *)
                if [ -z "$target" ]; then
                    target="$1"
                else
                    echo "Unexpected argument: $1"
                    exit $EXIT_USAGE
                fi
                shift
                ;;
        esac
    done

    # Load rate limit configuration
    load_rate_limit_config

    # Require target
    if [ -z "$target" ]; then
        echo "Error: Worker ID required"
        echo "Usage: wiggum resume <id> [-f]"
        exit $EXIT_USAGE
    fi

    # Resolve worker directory
    local worker_dir
    worker_dir=$(resolve_worker_id "$RALPH_DIR" "$target") || exit $EXIT_ERROR

    do_resume "$worker_dir" "$force_mode"
}

main "$@"
