#!/usr/bin/env bash
# wiggum resume - Resume a stopped worker using LLM-driven step decision
#
# Usage:
#   wiggum resume <id>        Resume a previously stopped worker
#   wiggum resume <id> -f     Force resume, clearing violation status

set -euo pipefail

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
source "$WIGGUM_HOME/lib/core/bin-common.sh"
source "$WIGGUM_HOME/lib/core/logger.sh"
source "$WIGGUM_HOME/lib/tasks/task-parser.sh"
source "$WIGGUM_HOME/lib/utils/audit-logger.sh"
source "$WIGGUM_HOME/lib/worker/worker-lifecycle.sh"
source "$WIGGUM_HOME/lib/worker/agent-registry.sh"
source "$WIGGUM_HOME/lib/core/agent-base.sh"
source "$WIGGUM_HOME/lib/git/git-operations.sh"
source "$WIGGUM_HOME/lib/core/file-lock.sh"
source "$WIGGUM_HOME/lib/claude/usage-tracker.sh"
source "$WIGGUM_HOME/lib/pipeline/pipeline-loader.sh"

# Default configuration
MAX_ITERATIONS=20
MAX_TURNS=50
QUIET_MODE=false

# Check if a step completed (has a result file) vs was interrupted (no result)
#
# A step that completed (even with FAIL) needs LLM analysis via resume-decide.
# A step that was interrupted mid-execution can be directly resumed.
#
# Args:
#   worker_dir - Worker directory path
#   step_id    - Step ID to check
#
# Returns: 0 if step completed (has result), 1 if interrupted (no result)
_step_has_result() {
    local worker_dir="$1"
    local step_id="$2"

    [ -d "$worker_dir/results" ] || return 1

    local result_file
    result_file=$(find "$worker_dir/results" -name "*-${step_id}-result.json" 2>/dev/null | sort -r | head -1)
    [ -f "$result_file" ]
}

# Get current step from pipeline config
#
# Args:
#   worker_dir - Worker directory path
#
# Echoes: step ID or empty string
_get_current_step() {
    local worker_dir="$1"
    local config_file="$worker_dir/pipeline-config.json"

    [ -f "$config_file" ] || return 0
    jq -r '.current.step_id // ""' "$config_file" 2>/dev/null
}

# Output message respecting quiet mode
_msg() {
    [ "$QUIET_MODE" = "true" ] || echo "$@"
}

show_help() {
    cat << EOF
wiggum resume - Resume a stopped worker

Usage:
  wiggum resume <id>        Resume a previously stopped worker
  wiggum resume <id> -f     Force resume, clearing violation status

The resume process:
  1. Converts worker logs to readable conversation format
  2. Runs an LLM agent to analyze what happened and decide the resume step
  3. Archives previous run artifacts (workspace is preserved)
  4. Launches a fresh system.task-worker from the decided step

Resume Steps:
  Steps are loaded dynamically from the pipeline config (config/pipeline.json
  or .ralph/pipeline.json). The LLM decides which step to resume from based
  on its analysis of the previous run. Common steps in the default pipeline:
    planning, execution, summary, audit, test, docs, validation

Worker ID Resolution:
  Worker IDs can be partial as long as they match exactly one worker:
  - 1891712              (timestamp)
  - K-030                (partial task ID)
  - TASK-030             (task ID)
  - worker-TASK-030-1891712  (full ID)

Options:
  --max-iters N   Maximum iterations per worker (default: 20)
  --max-turns N   Maximum turns per Claude session (default: 50)
  --pipeline NAME Pipeline config to use (from config/pipelines/ or config/)
  -f              Force resume, clearing any workspace violation status.
                  Use this after manually resolving violations.
  -v, --verbose   Verbose output (same as default)
  -vv             Debug output (detailed diagnostics)
  -vvv            Trace output (very detailed tracing)
  -q, --quiet     Quiet mode (warnings and errors only)
  -h, --help      Show this help message

Resume Logic:
  - If the current step has a result file (step completed), the resume-decide
    agent analyzes logs to determine the correct resume point
  - If the current step has no result file (step was interrupted mid-execution),
    resumes directly from that step without LLM analysis

Examples:
  wiggum resume TASK-030            # Resume worker for TASK-030
  wiggum resume 1891712             # Resume worker by timestamp
  wiggum resume TASK-030 -f         # Force resume after fixing violations
  wiggum resume TASK-030 --pipeline fast  # Resume using fast pipeline

EOF
}

# Resume a stopped worker
do_resume() {
    local worker_dir="$1"
    local force_mode="${2:-false}"
    local worker_id
    worker_id=$(basename "$worker_dir")
    local task_id
    # Match any task prefix format: TASK-001, PIPELINE-001, etc.
    task_id=$(echo "$worker_id" | sed -E 's/worker-([A-Za-z]{2,10}-[0-9]{1,4})-.*/\1/')

    # Initialize logging for resume command
    mkdir -p "$RALPH_DIR/logs"
    export LOG_FILE="$RALPH_DIR/logs/resume.log"
    source "$WIGGUM_HOME/lib/utils/activity-log.sh"
    activity_init "$PROJECT_DIR"

    log "Resuming worker $worker_id"
    log_debug "worker_dir=$worker_dir"
    log_debug "task_id=$task_id"
    log_debug "force_mode=$force_mode"
    activity_log "resume.started" "$worker_id" "$task_id"

    # Check if already running
    if [ -f "$worker_dir/agent.pid" ]; then
        local existing_pid
        existing_pid=$(cat "$worker_dir/agent.pid" 2>/dev/null)
        if kill -0 "$existing_pid" 2>/dev/null; then
            echo "Error: Worker $worker_id is already running (PID: $existing_pid)"
            exit $EXIT_ERROR
        fi
    fi

    # Check main repo is clean (prevents workspace violations)
    local dirty_files
    dirty_files=$(cd "$PROJECT_DIR" && git status --porcelain 2>/dev/null | grep -v "^.. .ralph/" || true)
    if [ -n "$dirty_files" ]; then
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "MAIN REPO HAS UNCOMMITTED CHANGES"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""
        echo "Cannot resume worker - main repository has uncommitted changes:"
        echo "$dirty_files" | head -10
        echo ""
        echo "This would cause workspace boundary violations."
        echo "Please commit or stash your changes first."
        echo ""
        exit $EXIT_ERROR
    fi

    # Check for workspace violations
    if [ -f "$worker_dir/violation_status.txt" ]; then
        local violation_status
        violation_status=$(cat "$worker_dir/violation_status.txt" 2>/dev/null)
        if [ "$violation_status" = "WORKSPACE_VIOLATION" ]; then
            if [ "$force_mode" = "true" ]; then
                echo "Warning: Clearing workspace violation status (forced)"
                rm -f "$worker_dir/violation_status.txt"
            else
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "WORKSPACE VIOLATION DETECTED"
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo ""
                echo "This worker was previously stopped due to a workspace violation."
                echo "Files were modified outside the worker's isolated workspace."
                echo ""
                echo "Before resuming, you should:"
                echo "  1. Review the violation log: $RALPH_DIR/logs/violations.log"
                echo "  2. Ensure no uncommitted changes exist in the main repo"
                echo "  3. Manually inspect $worker_dir/workspace for issues"
                echo ""
                echo "To force resume (clears violation status):"
                echo "  wiggum resume $worker_id -f"
                echo ""
                exit $EXIT_ERROR
            fi
        fi
    fi

    # Check PRD exists
    if [ ! -f "$worker_dir/prd.md" ]; then
        echo "Error: PRD not found at $worker_dir/prd.md"
        exit $EXIT_ERROR
    fi

    # Check workspace exists
    if [ ! -d "$worker_dir/workspace" ]; then
        echo "Error: Workspace not found at $worker_dir/workspace"
        echo "The worktree may have been cleaned up."
        exit $EXIT_ERROR
    fi

    _msg "Resuming worker $worker_id for task $task_id"
    _msg ""

    # === STEP 1: Check if step completed vs was interrupted ===
    local current_step resume_step needs_resume_decide=true resume_result_file=""
    current_step=$(_get_current_step "$worker_dir")

    if [ -n "$current_step" ] && ! _step_has_result "$worker_dir" "$current_step"; then
        # Step was interrupted mid-execution (no result file)
        # Direct resume is appropriate - no need for LLM analysis
        needs_resume_decide=false
        resume_step="$current_step"
        _msg "Step '$current_step' was interrupted (no result file) - resuming directly"
    else
        # Step completed (has result file) or no current step recorded
        # Need LLM to analyze what happened and decide resume point
        _msg "Step '${current_step:-unknown}' completed - running resume-decide agent"
    fi

    # === STEP 2: Convert logs to conversations (if needed for resume-decide) ===
    if [ "$needs_resume_decide" = "true" ]; then
        _msg "Converting logs to readable conversations..."
        if [ -d "$worker_dir/logs" ]; then
            "$WIGGUM_HOME/lib/utils/log-converter.sh" --dir "$worker_dir"
        else
            _msg "  No logs directory found — starting fresh"
            mkdir -p "$worker_dir/conversations"
            # Create a minimal worker.log so system.resume-decide has something to read
            if [ ! -f "$worker_dir/worker.log" ]; then
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] Worker was interrupted before producing logs" > "$worker_dir/worker.log"
            fi
        fi

        # === STEP 3: Run system.resume-decide agent ===
        _msg "Analyzing previous run to decide resume step..."
        run_agent "system.resume-decide" "$worker_dir" "$PROJECT_DIR" 0 1 25

        # === STEP 4: Read decision and recovery metadata ===
        resume_step=$(cat "$worker_dir/resume-step.txt" 2>/dev/null || echo "ABORT")
        resume_step=$(echo "$resume_step" | tr -d '[:space:]')

        # Get the result file path for later use (workspace recovery, instructions)
        resume_result_file=$(agent_find_latest_result "$worker_dir" "system.resume-decide")

        if [ "$resume_step" = "ABORT" ]; then
            _msg ""
            _msg "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            _msg "RESUME ABORTED"
            _msg "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            _msg ""
            local abort_report
            abort_report=$(agent_find_latest_report "$worker_dir" "system.resume-decide")
            if [ -n "$abort_report" ] && [ -f "$abort_report" ]; then
                _msg "Reason:"
                [ "$QUIET_MODE" = "true" ] || cat "$abort_report"
            fi
            _msg ""
            exit $EXIT_ERROR
        fi
    fi

    # === STEP 5: Load pipeline config ===
    # Load the pipeline to validate the resume step against actual step IDs
    local pipeline_file
    pipeline_file=$(pipeline_resolve "$PROJECT_DIR" "$task_id" "${WIGGUM_PIPELINE:-}")
    if [ -n "$pipeline_file" ]; then
        pipeline_load "$pipeline_file" || {
            _msg "Error: Failed to load pipeline config: $pipeline_file"
            exit $EXIT_ERROR
        }
    else
        pipeline_load_builtin_defaults
    fi

    # Validate step exists in pipeline
    local step_idx
    step_idx=$(pipeline_find_step_index "$resume_step")
    if [ "$step_idx" = "-1" ]; then
        # Build list of valid step IDs for error message
        local valid_steps=""
        local count
        count=$(pipeline_step_count)
        for ((i=0; i<count; i++)); do
            local sid
            sid=$(pipeline_get "$i" ".id")
            if [ -n "$valid_steps" ]; then
                valid_steps="$valid_steps, $sid"
            else
                valid_steps="$sid"
            fi
        done
        _msg "Error: Invalid resume step '$resume_step'"
        _msg "Valid steps from pipeline '$PIPELINE_NAME': $valid_steps"
        exit $EXIT_ERROR
    fi

    log "Resume decision: start from '$resume_step' step (index $step_idx)"
    log_debug "needs_resume_decide=$needs_resume_decide"
    activity_log "resume.decision" "$worker_id" "$task_id" "resume_step=$resume_step" "step_idx=$step_idx"

    _msg "Resume decision: start from '$resume_step' step (index $step_idx)"
    _msg ""

    # === STEP 5.5: Handle workspace recovery if needed ===
    # Check if we should reset workspace to a known checkpoint
    if [ "$needs_resume_decide" = "true" ]; then
        local last_checkpoint recovery_possible
        if [ -n "$resume_result_file" ] && [ -f "$resume_result_file" ]; then
            last_checkpoint=$(jq -r '.outputs.workspace_recovery.last_checkpoint_step // ""' "$resume_result_file" 2>/dev/null)
            recovery_possible=$(jq -r '.outputs.workspace_recovery.recovery_possible // false' "$resume_result_file" 2>/dev/null)
        fi

        if [ "$recovery_possible" = "true" ] && [ -n "$last_checkpoint" ]; then
            _msg "Workspace recovery checkpoint available: $last_checkpoint"

            # Find the commit from the checkpoint step
            # Commits are tagged with the step name in the message
            local checkpoint_commit
            checkpoint_commit=$(cd "$worker_dir/workspace" && \
                git log --oneline --all --grep="$last_checkpoint" -1 --format="%H" 2>/dev/null || true)

            if [ -n "$checkpoint_commit" ]; then
                _msg "  Found checkpoint commit: ${checkpoint_commit:0:8}"

                # Check if workspace has uncommitted changes that would be lost
                local has_changes
                has_changes=$(cd "$worker_dir/workspace" && git status --porcelain 2>/dev/null | head -1)

                if [ -n "$has_changes" ]; then
                    _msg "  Workspace has uncommitted changes - preserving current state"
                    _msg "  (Use 'git reset --hard $checkpoint_commit' manually to reset if needed)"
                else
                    _msg "  Workspace has no uncommitted changes - ready for recovery"
                fi
            else
                _msg "  Note: No commit found for checkpoint '$last_checkpoint'"
                _msg "  Workspace state may be uncertain - proceeding anyway"
            fi
        fi
    fi
    _msg ""

    # === STEP 6: Check rate limit before launching ===
    # Update usage data and check rate limit (orchestrator may not be running)
    usage_tracker_write_shared "$RALPH_DIR" > /dev/null 2>&1 || true
    if rate_limit_check "$RALPH_DIR"; then
        log "Rate limit threshold reached - waiting for cycle reset before resuming"
        rate_limit_wait_for_cycle_reset
        usage_tracker_write_shared "$RALPH_DIR" > /dev/null 2>&1 || true
    fi

    # === STEP 7: Launch system.task-worker ===
    # Always use normal system.task-worker (not plan-mode) — it picks up existing plan files
    _msg "Launching system.task-worker from step: $resume_step"

    mkdir -p "$RALPH_DIR/logs"

    # Launch agent in background using setsid to create a new session/process group.
    # This prevents SIGINT from the parent (wiggum resume) from killing the worker.
    #
    # Security: Pass variables via environment exports, not string interpolation.
    # This prevents command injection if any variable contains shell metacharacters.
    export _WORKER_WIGGUM_HOME="$WIGGUM_HOME"
    export _WORKER_DIR="$worker_dir"
    export _WORKER_PROJECT_DIR="$PROJECT_DIR"
    export _WORKER_MAX_ITERATIONS="$MAX_ITERATIONS"
    export _WORKER_MAX_TURNS="$MAX_TURNS"
    export _WORKER_RESUME_STEP="$resume_step"

    # Read report path from result file (standard mechanism)
    # Note: resume_result_file may already be set from step 4 (resume-decide analysis)
    local resume_instructions_path=""
    if [ -z "${resume_result_file:-}" ]; then
        resume_result_file=$(agent_find_latest_result "$worker_dir" "system.resume-decide")
    fi
    if [ -n "$resume_result_file" ] && [ -f "$resume_result_file" ]; then
        resume_instructions_path=$(jq -r '.outputs.report_file // ""' "$resume_result_file")
    fi
    export _WORKER_RESUME_INSTRUCTIONS="${resume_instructions_path:-}"

    # shellcheck disable=SC2016
    setsid bash -c '
        set -euo pipefail
        _log_ts() { echo "[$(date -Iseconds)] $*"; }
        _log_ts "INFO: Worker subprocess starting (resume)"
        _log_ts "INFO: WIGGUM_HOME=$_WORKER_WIGGUM_HOME"
        _log_ts "INFO: worker_dir=$_WORKER_DIR"
        _log_ts "INFO: resume_step=$_WORKER_RESUME_STEP"

        export WIGGUM_HOME="$_WORKER_WIGGUM_HOME"

        if ! source "$WIGGUM_HOME/lib/worker/agent-registry.sh" 2>&1; then
            _log_ts "ERROR: Failed to source agent-registry.sh"
            exit 1
        fi

        _log_ts "INFO: Running agent system.task-worker"
        run_agent "system.task-worker" "$_WORKER_DIR" "$_WORKER_PROJECT_DIR" 30 "$_WORKER_MAX_ITERATIONS" "$_WORKER_MAX_TURNS" \
            "$_WORKER_RESUME_STEP" "$_WORKER_RESUME_INSTRUCTIONS"
        local _exit_code=$?
        if [ $_exit_code -ne 0 ]; then
            _log_ts "ERROR: run_agent failed with exit code $_exit_code"
            exit 1
        fi
    ' >> "$RALPH_DIR/logs/workers.log" 2>&1 &

    # Wait briefly for agent.pid to be created
    local wait_count=0
    while [ ! -f "$worker_dir/agent.pid" ] && [ $wait_count -lt 10 ]; do
        sleep 0.1
        ((wait_count++)) || true
    done

    if [ -f "$worker_dir/agent.pid" ]; then
        local worker_pid
        worker_pid=$(cat "$worker_dir/agent.pid")
        _msg "Worker running (PID: $worker_pid)"
    else
        _msg "Worker started (PID file pending)"
    fi
    _msg "Use 'wiggum monitor' to follow progress"
}

# Main
main() {
    # Parse verbose flags first
    parse_verbose_flags "$@"
    set -- "${WIGGUM_REMAINING_ARGS[@]}"

    # Map LOG_LEVEL=WARN to QUIET_MODE for backward compatibility
    if [[ "${LOG_LEVEL:-}" == "WARN" ]]; then
        QUIET_MODE=true
    fi

    local force_mode=false
    local target=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit $EXIT_OK
                ;;
            -f)
                force_mode=true
                shift
                ;;
            --max-iters)
                if [[ -z "${2:-}" ]] || [[ "${2:-}" =~ ^- ]]; then
                    echo "Error: --max-iters requires a number argument"
                    exit $EXIT_USAGE
                fi
                MAX_ITERATIONS="$2"
                shift 2
                ;;
            --max-turns)
                if [[ -z "${2:-}" ]] || [[ "${2:-}" =~ ^- ]]; then
                    echo "Error: --max-turns requires a number argument"
                    exit $EXIT_USAGE
                fi
                MAX_TURNS="$2"
                shift 2
                ;;
            --pipeline)
                if [[ -z "${2:-}" ]] || [[ "${2:-}" =~ ^- ]]; then
                    echo "Error: --pipeline requires a name argument"
                    exit $EXIT_USAGE
                fi
                export WIGGUM_PIPELINE="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1"
                show_help
                exit $EXIT_USAGE
                ;;
            *)
                if [ -z "$target" ]; then
                    target="$1"
                else
                    echo "Unexpected argument: $1"
                    exit $EXIT_USAGE
                fi
                shift
                ;;
        esac
    done

    # Load rate limit configuration
    load_rate_limit_config

    # Require target
    if [ -z "$target" ]; then
        echo "Error: Worker ID required"
        echo "Usage: wiggum resume <id> [-f]"
        exit $EXIT_USAGE
    fi

    # Resolve worker directory
    local worker_dir
    worker_dir=$(resolve_worker_id "$RALPH_DIR" "$target") || exit $EXIT_ERROR

    do_resume "$worker_dir" "$force_mode"
}

main "$@"
