#!/usr/bin/env bash
# wiggum worker - Manage individual workers
#
# Commands:
#   wiggum worker <id> stop       Gracefully stop a worker (SIGTERM)
#   wiggum worker <id> kill       Immediately terminate a worker (SIGKILL)
#   wiggum worker <id> resume     Resume a previously stopped worker
#   wiggum worker start <TASK-ID> Start a new worker for a task

set -euo pipefail

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
PROJECT_DIR="$(pwd)"
RALPH_DIR="$PROJECT_DIR/.ralph"

# Source shared libraries
source "$WIGGUM_HOME/lib/logger.sh"
source "$WIGGUM_HOME/lib/task-parser.sh"
source "$WIGGUM_HOME/lib/audit-logger.sh"
source "$WIGGUM_HOME/lib/worker-lifecycle.sh"
source "$WIGGUM_HOME/lib/validation-review.sh"
source "$WIGGUM_HOME/lib/git-operations.sh"

# Default configuration (can be overridden by env vars)
MAX_ITERATIONS="${WIGGUM_MAX_ITERATIONS:-20}"
MAX_TURNS="${WIGGUM_MAX_TURNS:-50}"

show_help() {
    cat << EOF
wiggum worker - Manage individual workers

Usage:
  wiggum worker <id> stop         Gracefully stop a worker (SIGTERM)
  wiggum worker <id> kill         Immediately terminate a worker (SIGKILL)
  wiggum worker <id> resume [-f]  Resume a previously stopped worker
  wiggum worker start <TASK-ID>   Start a new worker for a task

Resume Options:
  -f    Force resume, clearing any workspace violation status.
        Use this after manually resolving violations.

Worker ID Resolution:
  Worker IDs can be partial as long as they match exactly one worker:
  - 1891712              (timestamp)
  - K-030                (partial task ID)
  - TASK-030             (task ID)
  - worker-TASK-030-1891712  (full ID)

Examples:
  wiggum worker TASK-030 stop       # Stop worker for TASK-030
  wiggum worker 1891712 resume      # Resume worker by timestamp
  wiggum worker TASK-030 resume -f  # Force resume after fixing violations
  wiggum worker start TASK-040      # Start new worker for TASK-040

EOF
}

# resolve_worker_id is now provided by lib/worker-lifecycle.sh

# get_worker_pid is now provided by lib/worker-lifecycle.sh

# Stop worker gracefully (SIGTERM)
cmd_stop() {
    local worker_dir="$1"
    local worker_id
    worker_id=$(basename "$worker_dir")

    local pid
    pid=$(get_worker_pid "$worker_dir") || exit 1

    echo "Stopping worker $worker_id (PID: $pid)..."
    kill -TERM "$pid"

    # Wait for graceful shutdown (up to 30 seconds)
    local timeout=30
    local elapsed=0
    while kill -0 "$pid" 2>/dev/null && [ $elapsed -lt $timeout ]; do
        sleep 1
        ((elapsed++))
        echo -ne "\rWaiting for worker to stop... ${elapsed}s"
    done
    echo ""

    if kill -0 "$pid" 2>/dev/null; then
        echo "Warning: Worker did not stop gracefully within ${timeout}s"
        echo "Use 'wiggum worker $(basename "$worker_dir") kill' to force terminate"
        exit 1
    else
        echo "Worker $worker_id stopped successfully"
        rm -f "$worker_dir/worker.pid"
    fi
}

# Kill worker immediately (SIGKILL)
cmd_kill() {
    local worker_dir="$1"
    local worker_id
    worker_id=$(basename "$worker_dir")

    local pid
    pid=$(get_worker_pid "$worker_dir") || exit 1

    echo "Force killing worker $worker_id (PID: $pid)..."
    kill -9 "$pid" 2>/dev/null || true

    sleep 1
    if kill -0 "$pid" 2>/dev/null; then
        echo "Error: Failed to kill worker $worker_id"
        exit 1
    else
        echo "Worker $worker_id killed"
        rm -f "$worker_dir/worker.pid"
    fi
}

# Determine which iteration to resume from
determine_resume_iteration() {
    local worker_dir="$1"
    local logs_dir="$worker_dir/logs"
    local max_iter=-1

    # Find the highest iteration number
    if [ -d "$logs_dir" ]; then
        for log_file in "$logs_dir"/iteration-*.log; do
            [ -f "$log_file" ] || continue
            local iter
            iter=$(basename "$log_file" | sed 's/iteration-\([0-9]*\).log/\1/')
            if [ "$iter" -gt "$max_iter" ]; then
                max_iter=$iter
            fi
        done
    fi

    if [ "$max_iter" -lt 0 ]; then
        # No iterations found, start from 0
        echo "0"
        return
    fi

    # If N has summary, resume from N+1; else redo N
    if [ -f "$worker_dir/iteration-${max_iter}-summary.txt" ]; then
        echo "$((max_iter + 1))"
    else
        echo "$max_iter"
    fi
}

# Prepare context for resume
prepare_resume_context() {
    local worker_dir="$1"
    local resume_iter="$2"

    if [ "$resume_iter" -gt 0 ]; then
        local prev_iter=$((resume_iter - 1))
        local prev_summary="$worker_dir/iteration-${prev_iter}-summary.txt"

        if [ -f "$prev_summary" ]; then
            # Use the previous summary as context
            cp "$prev_summary" "$worker_dir/resume-context.md"
            echo "Using summary from iteration $prev_iter as context"
        else
            # No summary available, try to generate from log
            local prev_log="$worker_dir/logs/iteration-${prev_iter}.log"
            if [ -f "$prev_log" ]; then
                echo "Converting iteration $prev_iter log to markdown..."
                "$WIGGUM_HOME/lib/log-converter.sh" "$prev_log" "$worker_dir/resume-context.md"
            else
                echo "Warning: No context available for resume (starting fresh)"
                touch "$worker_dir/resume-context.md"
            fi
        fi
    else
        # Starting from iteration 0, no context needed
        touch "$worker_dir/resume-context.md"
    fi
}

# Resume from validation phase (summary.txt exists, work is complete)
# Runs validation review, then commits and creates PR if passed
# Uses shared libraries: validation-review.sh and git-operations.sh
resume_from_validation() {
    local worker_dir="$1"
    local task_id="$2"

    # Register as worker with PID (same as worker.sh does)
    echo "$$" > "$worker_dir/worker.pid"

    # Cleanup PID on exit (success or failure)
    trap "rm -f '$worker_dir/worker.pid'" EXIT

    # Mark task as in-progress before running validation
    update_kanban_status "$PROJECT_DIR/.ralph/kanban.md" "$task_id" "="

    # Run validation review using shared library
    run_validation_review "$worker_dir" 50

    # Check validation result
    if ! check_validation_result "$worker_dir"; then
        local result
        result=$(cat "$worker_dir/validation-result.txt" 2>/dev/null || echo "UNKNOWN")
        echo "Validation $result - cannot proceed with commit/PR"
        # Mark task as failed in kanban
        update_kanban_failed "$PROJECT_DIR/.ralph/kanban.md" "$task_id"
        return 1
    fi

    echo "Validation PASSED - creating commit and PR..."

    # Use shared library for git operations
    if git_finalize_worker "$worker_dir" "$task_id" "$PROJECT_DIR"; then
        echo "PR URL: $GIT_PR_URL"

        # Update kanban to done
        if update_kanban "$PROJECT_DIR/.ralph/kanban.md" "$task_id"; then
            echo "Task $task_id marked as complete in kanban"
        fi

        return 0
    else
        echo "Failed to create commit/PR"
        update_kanban_failed "$PROJECT_DIR/.ralph/kanban.md" "$task_id"
        return 1
    fi
}

# Resume a stopped worker
cmd_resume() {
    local worker_dir="$1"
    local force_mode="${2:-false}"
    local worker_id
    worker_id=$(basename "$worker_dir")
    local task_id
    task_id=$(echo "$worker_id" | sed -E 's/worker-(TASK-[0-9]+)-.*/\1/')

    # Check if already running
    if [ -f "$worker_dir/worker.pid" ]; then
        local existing_pid
        existing_pid=$(cat "$worker_dir/worker.pid" 2>/dev/null)
        if kill -0 "$existing_pid" 2>/dev/null; then
            echo "Error: Worker $worker_id is already running (PID: $existing_pid)"
            exit 1
        fi
    fi

    # Check main repo is clean (prevents workspace violations)
    local dirty_files
    dirty_files=$(cd "$PROJECT_DIR" && git status --porcelain 2>/dev/null | grep -v "^.. .ralph/" || true)
    if [ -n "$dirty_files" ]; then
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "⚠️  MAIN REPO HAS UNCOMMITTED CHANGES"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""
        echo "Cannot resume worker - main repository has uncommitted changes:"
        echo "$dirty_files" | head -10
        echo ""
        echo "This would cause workspace boundary violations."
        echo "Please commit or stash your changes first."
        echo ""
        exit 1
    fi

    # Check for workspace violations
    if [ -f "$worker_dir/violation_status.txt" ]; then
        local violation_status
        violation_status=$(cat "$worker_dir/violation_status.txt" 2>/dev/null)
        if [ "$violation_status" = "WORKSPACE_VIOLATION" ]; then
            if [ "$force_mode" = "true" ]; then
                echo "Warning: Clearing workspace violation status (forced)"
                rm -f "$worker_dir/violation_status.txt"
            else
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "⚠️  WORKSPACE VIOLATION DETECTED"
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo ""
                echo "This worker was previously stopped due to a workspace violation."
                echo "Files were modified outside the worker's isolated workspace."
                echo ""
                echo "Before resuming, you should:"
                echo "  1. Review the violation log: $RALPH_DIR/logs/violations.log"
                echo "  2. Ensure no uncommitted changes exist in the main repo"
                echo "  3. Manually inspect $worker_dir/workspace for issues"
                echo ""
                echo "To force resume (clears violation status):"
                echo "  wiggum worker $worker_id resume -f"
                echo ""
                exit 1
            fi
        fi
    fi

    # Check PRD exists
    if [ ! -f "$worker_dir/prd.md" ]; then
        echo "Error: PRD not found at $worker_dir/prd.md"
        exit 1
    fi

    # Check workspace exists
    if [ ! -d "$worker_dir/workspace" ]; then
        echo "Error: Workspace not found at $worker_dir/workspace"
        echo "The worktree may have been cleaned up."
        exit 1
    fi

    # Check if summary.txt exists - work is complete, run validation/finalize
    if [ -f "$worker_dir/summary.txt" ]; then
        echo "Summary found - work is complete, running validation and finalization..."
        resume_from_validation "$worker_dir" "$task_id"
        return $?
    fi

    # Determine resume iteration
    local resume_iteration
    resume_iteration=$(determine_resume_iteration "$worker_dir")

    echo "Resuming worker $worker_id for task $task_id"
    echo "Starting from iteration $resume_iteration"

    # Prepare context for resume
    prepare_resume_context "$worker_dir" "$resume_iteration"

    # Launch worker with resume context
    export WORKER_ID="$worker_id"
    export TASK_ID="$task_id"
    export WIGGUM_HOME
    export WIGGUM_MAX_ITERATIONS="$MAX_ITERATIONS"
    export WIGGUM_MAX_TURNS="$MAX_TURNS"
    export WIGGUM_RESUME_ITERATION="$resume_iteration"
    export WIGGUM_RESUME_CONTEXT="$worker_dir/resume-context.md"

    mkdir -p "$RALPH_DIR/logs"
    bash "$WIGGUM_HOME/lib/worker.sh" "$worker_dir" "$PROJECT_DIR" \
        >> "$RALPH_DIR/logs/workers.log" 2>&1 &

    # Wait briefly for worker.pid to be created (same as cmd_start)
    local wait_count=0
    while [ ! -f "$worker_dir/worker.pid" ] && [ $wait_count -lt 10 ]; do
        sleep 0.1
        ((wait_count++))
    done

    if [ -f "$worker_dir/worker.pid" ]; then
        local worker_pid=$(cat "$worker_dir/worker.pid")
        echo "Worker running (PID: $worker_pid)"
    else
        echo "Worker started (PID file pending)"
    fi
    echo "Use 'wiggum monitor' to follow progress"
}

# Start a new worker for a task
cmd_start() {
    local task_id="$1"

    if [ -z "$task_id" ]; then
        echo "Error: Task ID required"
        echo "Usage: wiggum worker start <TASK-ID>"
        exit 1
    fi

    # Validate task ID format (allow flexible format like TASK-XXX, FEAT-XXX, etc.)
    if ! [[ "$task_id" =~ ^[A-Za-z]+-[0-9]+$ ]]; then
        echo "Error: Invalid task ID format: $task_id"
        echo "Expected format: PREFIX-NUMBER (e.g., TASK-030, FEAT-001)"
        exit 1
    fi

    # Check .ralph directory exists
    if [ ! -d "$RALPH_DIR" ]; then
        echo "Error: No .ralph directory found. Run 'wiggum init' first."
        exit 1
    fi

    # Check if task exists in kanban
    if [ ! -f "$RALPH_DIR/kanban.md" ]; then
        echo "Error: No kanban.md found at $RALPH_DIR/kanban.md"
        exit 1
    fi

    if ! grep -q "\\*\\*\\[$task_id\\]\\*\\*" "$RALPH_DIR/kanban.md" 2>/dev/null; then
        echo "Error: Task $task_id not found in kanban.md"
        exit 1
    fi

    # Check if a worker already exists for this task (using shared library)
    local existing
    existing=$(find_any_worker_by_task_id "$RALPH_DIR" "$task_id")
    if [ -n "$existing" ]; then
        echo "Warning: Worker already exists for $task_id: $(basename "$existing")"
        echo "Use 'wiggum worker $task_id resume' to resume it, or clean it up first."
        exit 1
    fi

    # Create worker directory with unique timestamp
    local timestamp=$(date +%s)
    local worker_id="worker-${task_id}-${timestamp}"
    local worker_dir="$RALPH_DIR/workers/$worker_id"

    mkdir -p "$worker_dir"
    mkdir -p "$RALPH_DIR/logs"

    # Extract task from kanban and create worker PRD
    extract_task "$task_id" "$RALPH_DIR/kanban.md" > "$worker_dir/prd.md"

    echo "Starting worker $worker_id for task $task_id"

    # Launch worker in background
    # Worker writes its own PID to worker.pid - orchestrator can poll for it
    export WORKER_ID="$worker_id"
    export TASK_ID="$task_id"
    export WIGGUM_HOME
    export WIGGUM_MAX_ITERATIONS="$MAX_ITERATIONS"
    export WIGGUM_MAX_TURNS="$MAX_TURNS"

    bash "$WIGGUM_HOME/lib/worker.sh" "$worker_dir" "$PROJECT_DIR" \
        >> "$RALPH_DIR/logs/workers.log" 2>&1 &

    # Wait briefly for worker.pid to be created
    local wait_count=0
    while [ ! -f "$worker_dir/worker.pid" ] && [ $wait_count -lt 10 ]; do
        sleep 0.1
        ((wait_count++))
    done

    if [ -f "$worker_dir/worker.pid" ]; then
        local worker_pid=$(cat "$worker_dir/worker.pid")
        echo "Worker running (PID: $worker_pid)"
    else
        echo "Worker started (PID file pending)"
    fi
    echo "Use 'wiggum monitor' to follow progress"
}

# Main
main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 1
    fi

    case "$1" in
        -h|--help|help)
            show_help
            exit 0
            ;;
        start)
            cmd_start "$2"
            ;;
        *)
            # First arg is worker ID, second is action
            local partial_id="$1"
            local action="${2:-}"

            if [ -z "$action" ]; then
                echo "Error: Missing action (stop|kill|resume)"
                echo ""
                show_help
                exit 1
            fi

            local worker_dir
            worker_dir=$(resolve_worker_id "$RALPH_DIR" "$partial_id") || exit 1

            case "$action" in
                stop)
                    cmd_stop "$worker_dir"
                    ;;
                kill)
                    cmd_kill "$worker_dir"
                    ;;
                resume)
                    # Check for -f flag
                    local force_mode="false"
                    if [ "${3:-}" = "-f" ]; then
                        force_mode="true"
                    fi
                    cmd_resume "$worker_dir" "$force_mode"
                    ;;
                *)
                    echo "Error: Unknown action '$action'"
                    echo "Valid actions: stop, kill, resume"
                    exit 1
                    ;;
            esac
            ;;
    esac
}

main "$@"
