#!/usr/bin/env bash
# wiggum start - Manually start a worker for a task
#
# Usage:
#   wiggum start <TASK-ID>         Start a new worker for the specified task
#   wiggum start <TASK-ID> plan    Start with planning phase first

set -euo pipefail

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
PROJECT_DIR="$(pwd)"
RALPH_DIR="${RALPH_DIR:-$PROJECT_DIR/.ralph}"

# Security: Validate WIGGUM_HOME contains expected structure before sourcing
# This prevents sourcing malicious scripts from an attacker-controlled path
_validate_wiggum_home() {
    local home="$1"
    local required_files=(
        "lib/core/exit-codes.sh"
        "lib/core/logger.sh"
        "lib/core/file-lock.sh"
        "lib/worker/agent-registry.sh"
    )
    for f in "${required_files[@]}"; do
        if [ ! -f "$home/$f" ]; then
            echo "Error: Invalid WIGGUM_HOME - missing $f" >&2
            echo "WIGGUM_HOME='$home' does not appear to be a valid Chief Wiggum installation" >&2
            exit 1
        fi
    done
}
_validate_wiggum_home "$WIGGUM_HOME"

source "$WIGGUM_HOME/lib/core/exit-codes.sh"
source "$WIGGUM_HOME/lib/core/verbose-flags.sh"
source "$WIGGUM_HOME/lib/core/logger.sh"
source "$WIGGUM_HOME/lib/core/file-lock.sh"
source "$WIGGUM_HOME/lib/tasks/task-parser.sh"
source "$WIGGUM_HOME/lib/utils/audit-logger.sh"
source "$WIGGUM_HOME/lib/worker/worker-lifecycle.sh"
source "$WIGGUM_HOME/lib/worker/agent-registry.sh"
source "$WIGGUM_HOME/lib/runtime/runtime.sh"
source "$WIGGUM_HOME/lib/backend/claude/usage-tracker.sh"
source "$WIGGUM_HOME/lib/github/issue-sync.sh"

# Default configuration
MAX_ITERATIONS=20
MAX_TURNS=50
AGENT_TYPE="system.task-worker"
WORKER_DIR=""
QUIET_MODE=false
FOREGROUND_MODE=false

# Output message respecting quiet mode
_msg() {
    [ "$QUIET_MODE" = "true" ] || echo "$@"
}

show_help() {
    cat << EOF
wiggum start - Manually start a worker for a task

Usage:
  wiggum start <id>         Start a new worker for the specified task
  wiggum start <id> plan    Start with planning phase first

Task ID Resolution:
  Task IDs can be partial as long as they match exactly one task:
  - 030                (number only)
  - K-030              (partial task ID)
  - TASK-030           (full task ID)

Options:
  --max-iters N     Maximum iterations per worker (default: 20)
  --max-turns N     Maximum turns per Claude session (default: 50)
  --agent-type T    Agent type to use (default: system.task-worker)
  --pipeline NAME   Pipeline config to use (from config/pipelines/ or .ralph/pipelines/)
  --worker-dir DIR  Use existing worker directory instead of creating new one.
                    Useful for running a different pipeline on an existing worker.
  -v, --verbose     Verbose output (same as default)
  -vv               Debug output (detailed diagnostics)
  -vvv              Trace output (very detailed tracing)
  -q, --quiet       Quiet mode (warnings and errors only)
  -f, --foreground  Run in foreground (blocking). Default is to daemonize.
  -h, --help        Show this help message

Examples:
  wiggum start TASK-030          # Start worker for TASK-030
  wiggum start 030               # Start worker matching "030"
  wiggum start FEAT-001          # Start worker for FEAT-001
  wiggum start TASK-030 plan     # Start with planning phase
  wiggum start TASK-030 --worker-dir .ralph/workers/worker-TASK-030-123 --pipeline fast

Notes:
  - The task must exist in .ralph/kanban.md
  - Use 'plan' to run the plan-mode agent before execution
  - If a plan already exists in .ralph/plans/, it will be used automatically
  - Use 'wiggum run' for automated orchestration of multiple tasks
  - Use 'wiggum resume <id>' to resume a stopped worker

EOF
}

# Start a new worker for a task
do_start() {
    local input_id="$1"
    local worker_dir=""
    local task_id=""

    # Check .ralph directory exists
    if [ ! -d "$RALPH_DIR" ]; then
        echo "Error: No .ralph directory found. Run 'wiggum init' first."
        exit $EXIT_WORKER_NO_RALPH_DIR
    fi

    mkdir -p "$RALPH_DIR/logs"

    # Handle --worker-dir mode (run pipeline on existing worker)
    if [ -n "$WORKER_DIR" ]; then
        worker_dir="$WORKER_DIR"

        # Validate worker directory exists
        if [ ! -d "$worker_dir" ]; then
            echo "Error: Worker directory not found: $worker_dir"
            exit $EXIT_ERROR
        fi

        # Validate workspace exists
        if [ ! -d "$worker_dir/workspace" ]; then
            echo "Error: Workspace not found at $worker_dir/workspace"
            exit $EXIT_ERROR
        fi

        # Validate PRD exists
        if [ ! -f "$worker_dir/prd.md" ]; then
            echo "Error: PRD not found at $worker_dir/prd.md"
            exit $EXIT_ERROR
        fi

        # Extract task_id from worker directory name
        local worker_id
        worker_id=$(basename "$worker_dir")
        task_id=$(echo "$worker_id" | sed -E 's/worker-([A-Za-z]{2,10}-[0-9]{1,4})-.*/\1/')

        _msg "Starting pipeline on existing worker $worker_id (task: $task_id)"
    else
        # Normal mode: create new worker

        if [ -z "$input_id" ]; then
            echo "Error: Task ID required"
            echo "Usage: wiggum start <TASK-ID>"
            exit $EXIT_WORKER_MISSING_TASK_ID
        fi

        # Check if kanban exists
        if [ ! -f "$RALPH_DIR/kanban.md" ]; then
            echo "Error: No kanban.md found at $RALPH_DIR/kanban.md"
            exit $EXIT_WORKER_NO_KANBAN
        fi

        # Resolve partial task ID to full task ID
        task_id=$(resolve_task_id "$RALPH_DIR/kanban.md" "$input_id") || exit $EXIT_WORKER_TASK_NOT_FOUND

        # Check if a worker already exists for this task (using shared library)
        # Exclude plan workers (worker-TASK-xxx-plan-*) - those are read-only planning sessions
        local existing
        existing=$(find_any_worker_by_task_id "$RALPH_DIR" "$task_id" | grep -v -- '-plan-' || true)
        if [ -n "$existing" ]; then
            echo "Warning: Worker already exists for $task_id: $(basename "$existing")"
            echo "Use 'wiggum resume $task_id' to resume it, or 'wiggum clean $task_id' first."
            exit $EXIT_WORKER_ALREADY_EXISTS
        fi

        # Update kanban status to in-progress (wip)
        if ! update_kanban_status "$RALPH_DIR/kanban.md" "$task_id" "="; then
            echo "Warning: Failed to update kanban status to in-progress"
        fi

        # Update linked GitHub issue to in-progress
        github_issue_sync_task_status "$RALPH_DIR" "$task_id" "=" || true

        # Create worker directory with unique timestamp
        local timestamp
        timestamp=$(date +%s)
        local worker_id="worker-${task_id}-${timestamp}"
        worker_dir="$RALPH_DIR/workers/$worker_id"

        mkdir -p "$worker_dir"

        # Extract task from kanban and create worker PRD
        extract_task "$task_id" "$RALPH_DIR/kanban.md" > "$worker_dir/prd.md"

        _msg "Starting worker $worker_id for task $task_id"
    fi

    # Recompute usage before starting (ensures rate limit checks use fresh data)
    usage_tracker_write_shared "$RALPH_DIR" > /dev/null 2>&1 || true

    # Security: Pass variables via environment exports, not string interpolation.
    # This prevents command injection if any variable contains shell metacharacters.
    export _WORKER_WIGGUM_HOME="$WIGGUM_HOME"
    export _WORKER_DIR="$worker_dir"
    export _WORKER_AGENT_TYPE="$AGENT_TYPE"
    export _WORKER_PROJECT_DIR="$PROJECT_DIR"
    export _WORKER_MAX_ITERATIONS="$MAX_ITERATIONS"
    export _WORKER_MAX_TURNS="$MAX_TURNS"
    export _WORKER_PIPELINE="${WIGGUM_PIPELINE:-}"
    export _WORKER_RALPH_DIR="$RALPH_DIR"
    export _WORKER_TASK_ID="$task_id"

    if [ "$FOREGROUND_MODE" = "true" ]; then
        # Run in foreground (blocking) - used by orchestrator for proper PID tracking
        _msg "Running worker in foreground..."

        export WIGGUM_HOME="$_WORKER_WIGGUM_HOME"
        [ -n "$_WORKER_PIPELINE" ] && export WIGGUM_PIPELINE="$_WORKER_PIPELINE"

        source "$WIGGUM_HOME/lib/worker/agent-registry.sh"
        run_agent "$_WORKER_AGENT_TYPE" "$_WORKER_DIR" "$_WORKER_PROJECT_DIR" 30 "$_WORKER_MAX_ITERATIONS" "$_WORKER_MAX_TURNS"
    else
        # Launch agent in background (daemonize)
        # run_agent writes PID to agent.pid - orchestrator can poll for it
        # Use setsid to create a new session/process group for the worker
        # This prevents SIGINT from the orchestrator from killing workers

        # shellcheck disable=SC2016
        setsid bash -c '
            set -euo pipefail

            # Initialize logging early using proper logger infrastructure
            export WIGGUM_HOME="$_WORKER_WIGGUM_HOME"
            export LOG_FILE="$_WORKER_RALPH_DIR/logs/worker-bootstrap.log"
            source "$WIGGUM_HOME/lib/core/logger.sh"
            source "$WIGGUM_HOME/lib/utils/activity-log.sh"
            activity_init "$_WORKER_PROJECT_DIR"

            log "Worker bootstrap starting for task $_WORKER_TASK_ID"
            log_debug "worker_dir=$_WORKER_DIR"
            log_debug "agent_type=$_WORKER_AGENT_TYPE"
            log_debug "pipeline=${_WORKER_PIPELINE:-default}"
            log_debug "max_iterations=$_WORKER_MAX_ITERATIONS"
            log_debug "max_turns=$_WORKER_MAX_TURNS"

            activity_log "worker.bootstrap" "" "$_WORKER_TASK_ID" "agent=$_WORKER_AGENT_TYPE"

            [ -n "$_WORKER_PIPELINE" ] && export WIGGUM_PIPELINE="$_WORKER_PIPELINE"

            if ! source "$WIGGUM_HOME/lib/worker/agent-registry.sh" 2>&1; then
                log_error "Failed to source agent-registry.sh"
                exit 1
            fi

            log "Running agent $_WORKER_AGENT_TYPE"
            run_agent "$_WORKER_AGENT_TYPE" "$_WORKER_DIR" "$_WORKER_PROJECT_DIR" 30 "$_WORKER_MAX_ITERATIONS" "$_WORKER_MAX_TURNS"
            _exit_code=$?
            if [ $_exit_code -ne 0 ]; then
                log_error "run_agent failed with exit code $_exit_code"
                exit 1
            fi
            log "Worker bootstrap completed successfully"
        ' >> "$RALPH_DIR/logs/workers.log" 2>&1 &

        # Wait briefly for agent.pid to be created
        local wait_count=0
        while [ ! -f "$worker_dir/agent.pid" ] && [ $wait_count -lt 10 ]; do
            sleep 0.1
            ((++wait_count))
        done

        if [ -f "$worker_dir/agent.pid" ]; then
            local worker_pid
            worker_pid=$(cat "$worker_dir/agent.pid")
            _msg "Worker running (PID: $worker_pid)"
        else
            # Brief wait then check if agent failed
            sleep 0.3
            if tail -5 "$RALPH_DIR/logs/workers.log" 2>/dev/null | grep -q "ERROR:"; then
                echo "ERROR: Worker failed to start. Check .ralph/logs/workers.log" >&2
            else
                _msg "Worker started (PID file pending)"
            fi
        fi
        _msg "Use 'wiggum monitor' to follow progress"
    fi
}

# Main
main() {
    # Parse verbose flags first
    parse_verbose_flags "$@"
    set -- "${WIGGUM_REMAINING_ARGS[@]}"

    # Map LOG_LEVEL=WARN to QUIET_MODE for backward compatibility
    if [[ "${LOG_LEVEL:-}" == "WARN" ]]; then
        QUIET_MODE=true
    fi

    local task_id_arg=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit $EXIT_OK
                ;;
            --max-iters)
                if [[ -z "${2:-}" ]] || [[ "${2:-}" =~ ^- ]]; then
                    echo "Error: --max-iters requires a number argument"
                    exit $EXIT_USAGE
                fi
                MAX_ITERATIONS="$2"
                shift 2
                ;;
            --max-turns)
                if [[ -z "${2:-}" ]] || [[ "${2:-}" =~ ^- ]]; then
                    echo "Error: --max-turns requires a number argument"
                    exit $EXIT_USAGE
                fi
                MAX_TURNS="$2"
                shift 2
                ;;
            --agent-type)
                if [[ -z "${2:-}" ]] || [[ "${2:-}" =~ ^- ]]; then
                    echo "Error: --agent-type requires an argument"
                    exit $EXIT_USAGE
                fi
                AGENT_TYPE="$2"
                shift 2
                ;;
            --pipeline)
                if [[ -z "${2:-}" ]] || [[ "${2:-}" =~ ^- ]]; then
                    echo "Error: --pipeline requires a name argument"
                    exit $EXIT_USAGE
                fi
                export WIGGUM_PIPELINE="$2"
                shift 2
                ;;
            --worker-dir)
                if [[ -z "${2:-}" ]] || [[ "${2:-}" =~ ^- ]]; then
                    echo "Error: --worker-dir requires a path argument"
                    exit $EXIT_USAGE
                fi
                WORKER_DIR="$2"
                shift 2
                ;;
            -f|--foreground)
                FOREGROUND_MODE=true
                shift
                ;;
            plan)
                export WIGGUM_PLAN_MODE=true
                echo "Using plan mode"
                shift
                ;;
            -*)
                echo "Unknown option: $1"
                show_help
                exit $EXIT_USAGE
                ;;
            *)
                if [ -z "$task_id_arg" ]; then
                    task_id_arg="$1"
                else
                    echo "Unexpected argument: $1"
                    exit $EXIT_USAGE
                fi
                shift
                ;;
        esac
    done

    # Task ID is required unless --worker-dir is provided
    if [ -z "$task_id_arg" ] && [ -z "$WORKER_DIR" ]; then
        echo "Error: Task ID required (or use --worker-dir for existing worker)"
        echo "Usage: wiggum start <TASK-ID> [plan] [--max-iters N] [--max-turns N] [--pipeline NAME]"
        echo "       wiggum start --worker-dir <DIR> --pipeline <NAME>"
        exit $EXIT_USAGE
    fi

    do_start "$task_id_arg"
}

main "$@"
