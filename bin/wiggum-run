#!/usr/bin/env bash
# Chief Wiggum - Worker orchestration runner

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
PROJECT_DIR="$(pwd)"
RALPH_DIR="$PROJECT_DIR/.ralph"

source "$WIGGUM_HOME/lib/task-parser.sh"
source "$WIGGUM_HOME/lib/logger.sh"
source "$WIGGUM_HOME/lib/file-lock.sh"
source "$WIGGUM_HOME/lib/audit-logger.sh"

# Default configuration
MAX_WORKERS=4
MAX_ITERATIONS=50       # Max outer loop iterations per worker
MAX_TURNS=20           # Max turns per Claude session

show_help() {
    cat << EOF
wiggum run - Orchestrate workers for incomplete tasks

Usage: wiggum run [options]

Options:
  --max-workers N      Maximum concurrent workers (default: 4)
  --max-iters N        Maximum iterations per worker (default: 50)
  --max-turns N        Maximum turns per Claude session (default: 20)
  -h, --help          Show this help message

Examples:
  wiggum run                              # Start orchestration with defaults
  wiggum run --max-workers 8              # Start with max 8 workers
  wiggum run --max-iters 100 --max-turns 30  # Customize iteration/turn limits

Behavior:
  - Chief assigns pending tasks [ ] to workers
  - Tasks are marked in-progress [=] when assigned
  - Workers mark tasks complete [x] when done
  - Chief waits until all tasks are complete
  - New workers spawn as old ones finish (up to max)

EOF
}

spawn_worker() {
    local task_id="$1"
    local worker_id="worker-${task_id}-$$"
    local worker_dir="$RALPH_DIR/workers/$worker_id"

    # Create worker directory
    mkdir -p "$worker_dir"
    mkdir -p "$RALPH_DIR/logs"

    # Extract task from kanban and create worker PRD
    extract_task "$task_id" "$RALPH_DIR/kanban.md" > "$worker_dir/prd.md"

    # Launch worker
    export WORKER_ID="$worker_id"
    export TASK_ID="$task_id"
    export WIGGUM_HOME
    export WIGGUM_MAX_ITERATIONS="$MAX_ITERATIONS"
    export WIGGUM_MAX_TURNS="$MAX_TURNS"
    bash "$WIGGUM_HOME/lib/worker.sh" "$worker_dir" "$PROJECT_DIR" >> "$RALPH_DIR/logs/workers.log" 2>&1
}

main() {
    # Parse run options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --max-workers)
                if [[ -z "$2" ]] || [[ "$2" =~ ^- ]]; then
                    echo "Error: --max-workers requires a number argument"
                    exit 1
                fi
                MAX_WORKERS="$2"
                shift 2
                ;;
            --max-iters)
                if [[ -z "$2" ]] || [[ "$2" =~ ^- ]]; then
                    echo "Error: --max-iters requires a number argument"
                    exit 1
                fi
                MAX_ITERATIONS="$2"
                shift 2
                ;;
            --max-turns)
                if [[ -z "$2" ]] || [[ "$2" =~ ^- ]]; then
                    echo "Error: --max-turns requires a number argument"
                    exit 1
                fi
                MAX_TURNS="$2"
                shift 2
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                echo "Unknown option: $1"
                echo ""
                show_help
                exit 1
                ;;
            *)
                echo "Unknown argument: $1"
                echo ""
                show_help
                exit 1
                ;;
        esac
    done

    # Initialize project if needed
    if [ ! -d "$RALPH_DIR" ]; then
        log_error ".ralph/ directory not found. Run 'wiggum init' first."
        exit 1
    fi

    # Ensure only one orchestrator runs at a time
    local orchestrator_lock="$RALPH_DIR/.orchestrator.pid"

    # Check if another orchestrator is already running
    if [ -f "$orchestrator_lock" ]; then
        local existing_pid=$(cat "$orchestrator_lock" 2>/dev/null)

        # Validate PID is a number
        if [[ "$existing_pid" =~ ^[0-9]+$ ]]; then
            # Check if that process is still running and is wiggum-run
            if kill -0 "$existing_pid" 2>/dev/null; then
                if ps -p "$existing_pid" -o args= 2>/dev/null | grep -q "wiggum-run"; then
                    log_error "Another wiggum-run orchestrator is already running (PID: $existing_pid)"
                    echo ""
                    echo "Only one orchestrator can run at a time to prevent conflicts."
                    echo "If you're sure no orchestrator is running, remove: $orchestrator_lock"
                    exit 1
                else
                    # PID exists but it's not wiggum-run (PID reused)
                    log "Cleaning stale orchestrator lock (PID reused)"
                    rm -f "$orchestrator_lock"
                fi
            else
                # Process no longer running
                log "Cleaning stale orchestrator lock"
                rm -f "$orchestrator_lock"
            fi
        else
            # Invalid PID in lock file
            log "Cleaning invalid orchestrator lock"
            rm -f "$orchestrator_lock"
        fi
    fi

    # Create orchestrator lock file
    echo "$$" > "$orchestrator_lock"
    log "Created orchestrator lock (PID: $$)"

    # Track shutdown state
    local shutdown_requested=false

    # Setup trap to cleanup lock file on exit (normal or Ctrl+C)
    cleanup_orchestrator() {
        if [ "$shutdown_requested" = false ]; then
            log "Cleaning up orchestrator lock"
            shutdown_requested=true

            # Kill all active workers gracefully
            if [ ${#active_workers[@]} -gt 0 ]; then
                log "Terminating active workers..."
                for pid in "${!active_workers[@]}"; do
                    if kill -0 "$pid" 2>/dev/null; then
                        log "Sending SIGTERM to worker ${active_workers[$pid]} (PID: $pid)"
                        kill -TERM "$pid" 2>/dev/null || true
                    fi
                done

                # Wait a moment for graceful shutdown
                sleep 2

                # Force kill any remaining workers
                for pid in "${!active_workers[@]}"; do
                    if kill -0 "$pid" 2>/dev/null; then
                        log "Force killing worker ${active_workers[$pid]} (PID: $pid)"
                        kill -9 "$pid" 2>/dev/null || true
                    fi
                done
            fi

            rm -f "$orchestrator_lock"
        fi
    }
    trap cleanup_orchestrator EXIT

    # Handle INT and TERM signals specially to exit immediately
    handle_shutdown_signal() {
        log ""
        log "Shutdown signal received (Ctrl+C or SIGTERM)"
        cleanup_orchestrator
        exit 130  # Standard exit code for SIGINT
    }
    trap handle_shutdown_signal INT TERM

    if [ ! -f "$RALPH_DIR/kanban.md" ]; then
        log_error ".ralph/kanban.md not found. Create a kanban file first."
        exit 1
    fi

    # Check for clean git status
    if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
        log_error "Git working directory is not clean. Please commit or stash your changes before running."
        echo ""
        echo "Uncommitted changes detected:"
        git status --short
        exit 1
    fi

    # Pre-flight checks: Ensure SSH and GPG keys are cached
    log "Running pre-flight checks..."

    # Extract hostname from git remote
    local git_remote=$(git remote get-url origin 2>/dev/null)
    if [ -n "$git_remote" ]; then
        # Extract hostname from SSH URLs (git@github.com:user/repo.git or ssh://git@github.com/user/repo.git)
        local git_host=""
        if [[ "$git_remote" =~ ^git@([^:]+): ]]; then
            git_host="${BASH_REMATCH[1]}"
        elif [[ "$git_remote" =~ ^ssh://git@([^/]+)/ ]]; then
            git_host="${BASH_REMATCH[1]}"
        fi

        if [ -n "$git_host" ]; then
            echo "  → Testing SSH connection to $git_host..."
            if ! ssh -T "git@$git_host" 2>&1 | head -5; then
                log_error "SSH test failed. Please ensure your SSH keys are set up and the agent is running."
                echo ""
                echo "Try running: ssh -T git@$git_host"
                exit 1
            fi
            echo "  ✓ SSH connection successful"
        fi
    fi

    # Test GPG signing
    echo "  → Testing GPG key..."
    if echo "test" | gpg --clearsign >/dev/null 2>&1; then
        echo "  ✓ GPG key is cached and ready"
    else
        log_error "GPG test failed. Please ensure your GPG key is unlocked."
        echo ""
        echo "Try running: echo 'test' | gpg --clearsign"
        echo "You may need to unlock your GPG key or configure git signing."
        exit 1
    fi

    echo ""

    # Check for failed tasks and reset them to pending for retry
    local failed_tasks=$(get_failed_tasks "$RALPH_DIR/kanban.md")
    if [ -n "$failed_tasks" ]; then
        log "Found failed tasks - resetting for retry:"
        for task_id in $failed_tasks; do
            echo "  → Retrying $task_id"
            if ! update_kanban_status "$RALPH_DIR/kanban.md" "$task_id" " "; then
                log_error "Failed to reset $task_id to pending"
            fi
        done
        echo ""
    fi

    log "Starting Chief Wiggum in $PROJECT_DIR (max $MAX_WORKERS concurrent workers)"
    echo ""
    echo "⚠️  WARNING: Do NOT edit files in the main repository while workers are running!"
    echo "    Workers run in isolated git worktrees. Any uncommitted changes in the main"
    echo "    repo will cause workspace violation detection and task failures."
    echo ""
    echo "Press Ctrl+C to stop and view 'wiggum status' for details"
    echo "=========================================="
    echo ""

    # Track active workers
    declare -A active_workers  # PID -> task_id mapping
    local all_pids=()

    # Restore active workers from existing worker directories
    if [ -d "$RALPH_DIR/workers" ]; then
        log "Scanning for active workers from previous runs..."
        for worker_dir in "$RALPH_DIR/workers"/worker-*; do
            [ -d "$worker_dir" ] || continue

            local pid_file="$worker_dir/worker.pid"
            [ -f "$pid_file" ] || continue

            local worker_pid=$(cat "$pid_file" 2>/dev/null)
            local worker_id=$(basename "$worker_dir")
            local task_id=$(echo "$worker_id" | sed -E 's/worker-(TASK-[0-9]+)-.*/\1/')

            # Validate PID is a number
            if ! [[ "$worker_pid" =~ ^[0-9]+$ ]]; then
                log "Invalid PID in $pid_file, cleaning up"
                rm -f "$pid_file"
                continue
            fi

            # Only restore if process is still running and is a worker process
            if kill -0 "$worker_pid" 2>/dev/null; then
                # Verify it's actually a worker process (contains 'worker.sh' in command line)
                if ps -p "$worker_pid" -o args= 2>/dev/null | grep -q "lib/worker.sh"; then
                    active_workers[$worker_pid]="$task_id"
                    all_pids+=("$worker_pid")
                    log "Restored tracking for $task_id (PID: $worker_pid)"
                else
                    log "PID $worker_pid is not a worker process (PID reused?), cleaning stale PID file"
                    rm -f "$pid_file"
                fi
            else
                log "Worker $task_id (PID: $worker_pid) no longer running, cleaning stale PID file"
                rm -f "$pid_file"
            fi
        done
    fi

    local iteration=0

    # Main orchestration loop
    while true; do
        ((iteration++))
        # Get incomplete tasks ([ ] status)
        local pending_tasks=$(get_todo_tasks "$RALPH_DIR/kanban.md")

        # Clean up finished workers
        for pid in "${!active_workers[@]}"; do
            if ! kill -0 "$pid" 2>/dev/null; then
                log "Worker for ${active_workers[$pid]} finished (PID: $pid)"
                unset active_workers[$pid]
            fi
        done

        # Check if we're done (no pending tasks and no active workers)
        if [ -z "$pending_tasks" ] && [ ${#active_workers[@]} -eq 0 ]; then
            log "All tasks completed!"
            break
        fi

        # Spawn workers for pending tasks (up to MAX_WORKERS limit)
        for task_id in $pending_tasks; do
            # Check if we're at max capacity
            if [ ${#active_workers[@]} -ge $MAX_WORKERS ]; then
                break
            fi

            # Mark task as in-progress in kanban
            log "Assigning $task_id to new worker"
            if ! update_kanban_status "$RALPH_DIR/kanban.md" "$task_id" "="; then
                log_error "Failed to mark $task_id as in-progress"
                continue
            fi

            # Spawn worker
            spawn_worker "$task_id" &
            local worker_pid=$!
            active_workers[$worker_pid]="$task_id"
            all_pids+=($worker_pid)

            # Log task assignment to audit log
            local worker_id="worker-${task_id}-$$"
            audit_log_task_assigned "$task_id" "$worker_id" "$worker_pid"

            log "Spawned worker for $task_id (PID: $worker_pid)"
        done

        # Show status and recent activity
        if [ ${#active_workers[@]} -gt 0 ]; then
            echo ""
            echo "=== Status Update (iteration $iteration) ==="
            echo "Active workers: ${#active_workers[@]}/$MAX_WORKERS"

            # Show which tasks are being worked on
            echo "In Progress:"
            for pid in "${!active_workers[@]}"; do
                echo "  - ${active_workers[$pid]} (PID: $pid)"
            done

            # Show recent log activity (last 10 lines)
            if [ -f "$RALPH_DIR/logs/workers.log" ]; then
                echo ""
                echo "Recent activity:"
                tail -n 10 "$RALPH_DIR/logs/workers.log" 2>/dev/null | sed 's/^/  /'
            fi
            echo "=========================================="
        fi

        # Wait a bit before checking again
        sleep 5
    done

    echo ""
    echo "=========================================="
    log "Chief Wiggum finished - all tasks complete!"
    echo ""

    # Show final summary
    local completed_count=$(grep -c '^\- \[x\]' "$RALPH_DIR/kanban.md" 2>/dev/null || echo "0")
    echo "Summary:"
    echo "  - Total tasks completed: $completed_count"
    echo "  - Changelog: .ralph/changelog.md"
    echo ""
    echo "Next steps:"
    echo "  - Review completed work: wiggum review list"
    echo "  - Merge PRs: wiggum review merge-all"
    echo "  - Clean up: wiggum clean"
    echo ""
}

main "$@"
